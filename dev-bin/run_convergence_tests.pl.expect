==> b001 <==
  # State 1
  if ( $printer eq "" || $printer eq 'nulllp' ) {
    open( PRINTER, ">>/tmp/kohares" ) ;
  }

__END__

# State 2
  if ( $printer eq ""
    || $printer eq 'nulllp' )
  {
    open( PRINTER,
          ">>/tmp/kohares"
    ) ;
  }

==> b002 <==
#State 1
if (
         (
                  $search
                  [0
                  ] )
         and
         not(
                  $op
                  eq
'do_search'
         )
  )

__END__

# State 2

if (
         ( $search
         [0] )
         and
         not( $op
                  eq
'do_search'
         )
  )


==> b003 <==
# State 1
if (
         (
                  $search
                  [0
                  ] )
         and
         not(
                  $op
                  eq
'do_search'
         )
  )

__END__

# state 2

if (
         ( $search
         [0] )
         and
         not( $op
                  eq
'do_search'
         )
  )


==> b007 <==
# State 1

my $todaysdate =
  (
         1900 +
           $datearr
           [5] )
  . sprintf(
         "%0.2d",
         (
                  $datearr
                    [
                    3
                    ]
         )
  );

# State 2
my $todaysdate =
  (
         1900 +
           $datearr
           [5] )
  . sprintf(
         "%0.2d",
         (
                  $datearr
                    [
                    3
                    ]
         )
  );


==> b008 <==
# This is fixed by the update for Bug96 (sub store token_and_space)
# State 1

{
    my $warningdate = DateCalc(
                                $borrower->{'expiry'},
                                "- "
                                  . C4::Context->preference(
                                                      'NotifyBorrowerDeparture')
                                  . "  days"
    ) ;
}

# State 2

{
    my $warningdate = DateCalc(
                                $borrower->{'expiry'},
                                "- "
                                  . C4::Context->preference(
                                                      'NotifyBorrowerDeparture')
                                  . "  days"
    ) ;
}

==> b011 <==
# lp bug
open( CVSLOG,
      "cvs log $self_path|"
) ;

open( CVSLOG,
      "cvs log $self_path|"
) ;


==> b012 <==
  # Same as bug 96

  # State 1
  UpdateStats(
    $env,      $branch,
    'payment', $data,
    '',        '',
    '',        $bornumber );

  # state 2
  UpdateStats(
    $env,      $branch,
    'payment', $data,
    '',        '',
    '',        $bornumber );

==> b013 <==
# Fixed with same fix as for Bug95
{
  {
    {
      {
        push( @itemloop,
          \%overdueitem );
      }
    }
  }
}

==> b016 <==
# Fixed is same as Bug96, level of spaces created in sub store_token_and_space
# State 1

{
  {
    {
      {
        {
          push(
                @subfields_data,
                &create_input(
                               '', '', '', $i, $record, $authorised_values_sth
                )
          );
        }
      }
    }
  }
}

# State 2

{
  {
    {
      {
        {
          push(
                @subfields_data,
                &create_input(
                               '', '', '', $i, $record, $authorised_values_sth
                )
          );
        }
      }
    }
  }
}

==> b022 <==
      # Same as Bug 96
      # State 1
      push( @loop_data,
        \%subfield_data );

      build_tabs(
        $template,
        $record,
        $dbh,
        $encoding
      );

      # State 2
      push( @loop_data,
        \%subfield_data );

      build_tabs(
        $template,
        $record,
        $dbh,
        $encoding
      );

==> b023 <==
  # same as Bug96
  # State 1
  my ( $oldbibid, $oldauthor,
    $oldtitle );

  my ( $dbh, $tags,
    $and_or, $operator,
    $value )
          = @_;

  # State 2

  my ( $oldbibid, $oldauthor,
    $oldtitle );

  my ( $dbh, $tags,
    $and_or, $operator,
    $value )
          = @_;


==> b024 <==
       # State 1
       my@bind_values=
             ($authid,$tag,$subfieldcode );

       # State 2
       my@bind_values=
             ($authid,$tag,$subfieldcode );

==> b026 <==
		 my ( $nowaiting, $itemswaiting )=
		   CheckWaiting (
				  $patroninformation->{
						   'borrowernumber'} ) ;

		 my ( $nowaiting, $itemswaiting )=
		   CheckWaiting (
				  $patroninformation->{
						   'borrowernumber'} ) ;


==> b027 <==
  # State 1

  return (
           $dotransfer,
           $messages,
           $iteminformation
  );

  # State 2

  return (
           $dotransfer,
           $messages,
           $iteminformation
  );


==> b028 <==
        # State 1

        my $response =
          showmessage( getmessage( 'ConfirmPerlExecutableSymlink', $realperl ),
                       'yn', 'y', 1 ) ;

        # State2

        my $response = showmessage(
                                    getmessage(
                                                'ConfirmPerlExecutableSymlink',
                                                $realperl
                                    ),
                                    'yn', 'y', 1
        ) ;

==> b031 <==
# Fixed with same fix as for Bug96, level of spaces created in
# sub store_token_and_space
# State 1
my %fielddefinitions = (
              printers => [
                            { field => 'printername', type => 'char(40)', null => '', key => 'PRI',
                              default => '' },
              ],
);

# State 2

my %fielddefinitions = (
              printers => [
                            { field => 'printername', type => 'char(40)', null => '', key => 'PRI',
                              default => '' },
              ],
);

==> b033 <==
            $sth->execute(
                           $bibid, ( sprintf "%03s", $tagid ),
                           $tagorder,     $tag_indicator,
                           $subfieldcode, $subfieldorder,
                           $subfieldvalue
            ) ;

            $sth->execute(
                           $bibid, ( sprintf "%03s", $tagid ),
                           $tagorder,     $tag_indicator,
                           $subfieldcode, $subfieldorder,
                           $subfieldvalue
            ) ;

==> b034 <==
# Same as Bug96
# State 1:
{
    my $xml =
      MARC::File::XML::header( C4::Context->preference('TemplateEncoding'),
                               C4::Context->preference('marcflavour') ) ;
}

{
    {
        {
            $sth->execute(
                           $bibid, ( sprintf "%03s", $tagid ),
                           $tagorder,     $tag_indicator,
                           $subfieldcode, $subfieldorder,
                           $subfieldvalue
            ) ;
        }
    }
}

##############################################

# State 2

{
    my $xml = MARC::File::XML::header(
                                       C4::Context->preference(
                                                            'TemplateEncoding'),
                                       C4::Context->preference('marcflavour')
    ) ;
}

{
    {
        {
            $sth->execute(
                           $bibid, ( sprintf "%03s", $tagid ),
                           $tagorder,     $tag_indicator,
                           $subfieldcode, $subfieldorder,
                           $subfieldvalue
            ) ;
        }
    }
}

==> b035 <==
# state 1
my @frames
   = (
       0, 1, 2
   );

# state 2

my @frames
   = (
       0, 1, 2
   );


==> b036 <==
# This can be fixed with the modified list definition (2 commas, or 1 comma and 2 fat commas)
# State 1
   (
    $seqname,
    $aln_line
     )
     = ( $1,
    $2 );

   # State 2

   (
    $seqname,
    $aln_line
     )
     = ( $1,
    $2 );


==> b037 <==
    # State 1
    print p,
"This program also illustrates the power of ",
       a(
          {
           -href =>'http://www.BioPerl.org/'
          },
          "BioPerl"
       ),
       c;

    # State 2
    print p,
"This program also illustrates the power of ",
       a(
          {
           -href =>'http://www.BioPerl.org/'
          },
          "BioPerl"
       ),
       c;


==> b042 <==
# State 1
my @params
  =

  (
'quiet'
            =>
            1)
  ;

# State 2
my @params
  =

  (
'quiet'
            =>
            1)
  ;

==> b044 <==
# Same as bug96

 # State 1

 my ( $self,
  $sf,
  $locstr )
   = @_;

 push( @ret,
  @subfth );

 # state 2

 my ( $self,
  $sf,
  $locstr )
   = @_;

 push( @ret,
  @subfth );

==> b047 <==
my $example2values
  = [
    7, 9,
    25
  ];

my $example2values
  = [
    7, 9,
    25
  ];


==> b048 <==
BEGIN {
    *$func =
      sub {
        my ( $self,
            $value )
          = @_;
    }
}

BEGIN {
    *$func =
      sub {
        my ( $self,
            $value )
          = @_;
    }
}

==> b049 <==
 my ( $i,
  $len,
  $output )
   = ( 0, 0,
  '' );

 my ( $i,
  $len,
  $output )
   = ( 0, 0,
  '' );

==> b050 <==
         # State 1
         my@organell_names=
           ("chloroplast","mitochondr");

         # State 2
         my@organell_names=
           ("chloroplast","mitochondr" );

==> b051 <==
# state 1
@args = (
 '/usr/bin/compress', '-f', $fileName
);

# state 2
@args = (
 '/usr/bin/compress', '-f', $fileName
);

==> b054 <==
my (
    $mchar,
    $schar,
    $qchar );
while (
    $mchar =
    chop(
        $seqString) )
{
    ( $qchar,
        $schar )
      = (
        chop($qseq),
        chop($sseq)
      );
}

==> b055 <==
            # Same as Bug96
            # State 1
            $seq = substr(
                           $self->seq_str ('match'),
                           $beg - $start,
                           ( $end - $beg )
            );

            # State 2
            $seq = substr(
                           $self->seq_str ('match'),
                           $beg - $start,
                           ( $end - $beg )
            );

==> b057 <==
# State 1
@TypeUnivAln=
  ('unknown','dna','rna','amino','otherseq');

# State 2
@TypeUnivAln=
  ('unknown','dna','rna','amino','otherseq' );

==> b058 <==
            # Same as bug 96
            # State 1
            $Blast->throw( "Not a function reference: $func",
                          "The -filt_func parameter must be function reference."
            ) ;

            # State 2
            $Blast->throw( "Not a function reference: $func",
                          "The -filt_func parameter must be function reference."
            ) ;


==> b062 <==
@hits = (
    2378, 4024, 9696, 7314,
    2378, 4024, 9696, 7314,
    2378, 4024, 9696, 7314,
    2378, 4024, 9696, 7314,
    7710
) ;

==> b064 <==
# State 1

sub bb {
    for ( my $i =
          $first,
        my $j = 0 ;
        $i <=
          $last ;
      )
    {
        ...;
    }
}

# State 2 (changed sub name to avoid perltidy message)

sub bB {
    for ( my $i =
          $first,
        my $j = 0 ;
        $i <=
          $last ;
      )
    {
        ...;
    }
}
__END__

==> b068 <==
       # State 1
       for ($r[0]=0,
              my $i
                = 1
                ;
              $i<=
                $k;
              $i++)

         # State 2
         for (
              $r[0]
                = 0,
              my $i
                = 1
                ;
              $i<=
                $k;
              $i++)

==> b069 <==
return
  map {
    (
        $x[$_],
        $y[$_]
    )
  } 0
  .. $#h;

return
  map {
    (
        $x[$_],
        $y[$_]
    )
  } 0
  .. $#h;

==> b071 <==
my ( $lo_val, $hi_val ) =

(   &{$func}($lo_guess),
    &{$func}($hi_guess) );

my ( $lo_val, $hi_val ) =

(   &{$func}($lo_guess),
    &{$func}($hi_guess) );

==> b075 <==
        $sq->prepend (
                $cu->first->remove ($three)
        );

        $sq->prepend (
                $cu->first->remove ($three)
        );

==> b077 <==
# state 1

{
      my $S
         = {
            G =>
               $G
         };
}

# State 2

{
      my $S
         = {
            G =>
               $G
         };
}

==> b085 <==
                           push @ARGV2 =>
                             [ $dir, $intermediate++ ];

                           push @ARGV2 =>
                             [ $dir, $intermediate++ ];


==> b090 <==
# State 1

my $rows =
{
    1 => [ 1,  2,  3 ],
    2 => [ 4,  5,  6 ],
    3 => [ 7,  8,  9 ],
    4 => [ 10, 11, 12 ],
};

# State 2

my $rows =
{
    1 => [ 1,  2,  3 ],
    2 => [ 4,  5,  6 ],
    3 => [ 7,  8,  9 ],
    4 => [ 10, 11, 12 ],
};

==> b1002 <==
                  @cmd=
                            (
                           MIME::Base64::encode_base64(
                                    defined $token
                                    ? $token
                                    : '',
                                    '' ) );

==> b1003 <==
is(
    $CALC->_str(
                $CALC->_from_hex(
                          $CALC->_as_hex(
                                   $CALC->_new("128")
                          )
                )
    ),
    128,
    qq|$CALC->_str($CALC->_from_hex($CALC->_as_hex(|
              . qq|$CALC->_new("128")))) = 128|
);

is(
    $CALC->_str(
                $CALC->_from_hex(
                          $CALC->_as_hex(
                                   $CALC->_new("128")
                          )
                )
    ),
    128,
    qq|$CALC->_str($CALC->_from_hex($CALC->_as_hex(|
              . qq|$CALC->_new("128")))) = 128|
);

==> b1004 <==
                  @cmd=
                            (
                           MIME::Base64::encode_base64(
                                    $str, '' ) );

                  @cmd=
                            (
                           MIME::Base64::encode_base64(
                                    $str, '' ) );

==> b1005 <==
    # S1
    $x=
      &{$C
          ."::__strip_zeros"
      }
      ([0,1,2,0,0,0]);

    # S2
    $x=
      &{$C
          ."::__strip_zeros"
      }
      ([0,1,2,0,0,0]);

==> b1006 <==
# S1

is(
    $CALC->_str(
        scalar(
            $CALC
                   ->_div
                   (
                $x,$y)
        )),
    3,
qq|$CALC->_str(scalar($CALC->_div(\$x, \$y))) = 3|
);

# S2

is(
    $CALC->_str(
        scalar(
            $CALC
                   ->_div
                   (
                $x,$y)
        )),
    3,
qq|$CALC->_str(scalar($CALC->_div(\$x, \$y))) = 3|
);


==> b1007 <==
        # S1
        $wrapper_pkg=
               undef
               if(
            exists(
                $reusable_builtins{
                    $call
                }
            )) ;

        # S2

        $wrapper_pkg=
               undef
               if(
            exists(
                $reusable_builtins{
                    $call
                }
            )) ;

==> b1008 <==
    # Use test.pro.bak

      # S1
      unless(
            get_cache(
                  $Dircache,
                  \@Podpath,
                  $Podroot,
                  $Recurse
            ))

        # S2
        unless(
            get_cache(
                  $Dircache,
                  \@Podpath,
                  $Podroot,
                  $Recurse
            ))

==> b1009 <==
      # S1

      $hub->listen(
            sub{
                  push
                         @events
                         =>
                         $_
                         [
                         1
                         ]
                         ;
            }
      );

      # S2
      $hub->listen(
            sub{
                  push
                         @events
                         =>
                         $_
                         [
                         1
                         ]
                         ;
            }
      );


==> b1010 <==
            unless(
                  run(
                        command=>
                          $cmd,
                        buffer=>
                          \
                          $head,
                        verbose=>
                          $DEBUG
                  ))

              # S2
              unless(
                  run(
                        command=>
                          $cmd,
                        buffer=>
                          \
                          $head,
                        verbose=>
                          $DEBUG
                  ))

==> b1011 <==
      # S1
      $hub->listen(
            sub{
                  push
                         @$subevents
                         =>
                         $_
                         [
                         1
                         ]
                         ;
            }
      );

      # S2
      $hub->listen(
            sub{
                  push
                         @$subevents
                         =>
                         $_
                         [
                         1
                         ]
                         ;
            }
      );

==> b1012 <==
        if (
            length(
                int(
                    $yorg
                           ->
                           [
                           -1
                           ]
                )
            ) >
            length(
                int(
                    $x
                           ->
                           [
                           -1
                           ]
                )
            ))

               #
               if (
            length(
                int(
                    $yorg
                           ->
                           [
                           -1
                           ]
                )
            )>
            length(
                int(
                    $x
                           ->
                           [
                           -1
                           ]
                )
            ))


==> b1013 <==
            if (  eval
                  {
                        require
                          POSIX
                          ;
                  }
              )

__END__
# S2

            if (  eval
                  {
                        require
                          POSIX
                          ;
                  }
              )

==> b1014 <==
    # S1
    for my $f (
        Archive::Tar->list_archive (
            $perl->{source}
        )
      )

__END__
# S2
    for
      my $f (
        Archive::Tar->list_archive (
            $perl->{source} ) )


==> b1016 <==
# S1
return $dir eq File::Spec->rootdir ?
  File::Spec->catpath ( $vol, $dir,
    $file ) :
  fast_abs_path (
    File::Spec->catpath (
        $vol, $dir, ''
    )
  ) .
  '/' .
  $file;

# S2

return $dir eq File::Spec->rootdir ?
  File::Spec->catpath ( $vol, $dir,
    $file ) :
  fast_abs_path (
    File::Spec->catpath (
        $vol, $dir, ''
    )
  ) .
  '/' .
  $file;

==> b1017 <==
            # S1
            $res .=chr(
                utf8::unicode_to_native(
                    ord(substr($str, $i,
                            1)))
            );

            # S2
            $res .=chr(
                utf8::unicode_to_native(
                    ord(substr($str, $i,
                            1)))
            );


==> b1018 <==
# S1
foreach
         my $table
         (
    ('borrowers',
        'items',
        'biblio',
'biblioitems'
    )
         )
__END__
# S2
foreach my $table(
    (
'borrowers',
        'items',
        'biblio',
'biblioitems'
    )
         )

==> b1019 <==
# S1: welded but no equals break; this has length 70
my ( $template, $borrowernumber, $cookie ) =
  get_template_and_user ( {
                            template_name   => "opac-sendbasketform.tmpl",
                            query           => $query,
                            type            => "opac",
                            authnotrequired => 1,
                            flagsrequired   => { borrow => 1 },
  } );

# S2: Equals break, not welded. This welds but also removes the = break
# So we want to keep the = break if we make a weld
my ( $template, $borrowernumber, $cookie ) =
  get_template_and_user ( {
                            template_name   => "opac-sendbasketform.tmpl",
                            query           => $query,
                            type            => "opac",
                            authnotrequired => 1,
                            flagsrequired   => { borrow => 1 },
  } );

==> b1020 <==
# S1
{
 return(
        self->_testStrand($other,$so)and not((
                  $self->start()>$other->end()
                or$self->end()<$other->start()
        ))
 );
}

# S2
{
 return(self->_testStrand($other,$so)
          and not(
               (  $self->start()>$other->end()
                or$self->end()<$other->start()
               )
          )
 );
}

==> b1021 <==
# S1
$self->{LIBS} =
  ['-lndbm',
    -e "/usr/lib/libdbm.nfs.a" ? '-ldbm.nfs' : '-ldbm'] ;

$self->{LIBS} =
  ['-lndbm',
    -e "/usr/lib/libdbm.nfs.a" ? '-ldbm.nfs' : '-ldbm'] ;

==> b1022 <==
# State 1: This should stay static
use Test::Requires {
      'MooseX::MarkAsMethods' => 0,
};

# State 2:
use Test::Requires {
      'MooseX::MarkAsMethods' => 0,
};

==> b1024 <==
# S1
my%fielddefinitions=(
    z3950servers=>
            [
             {field=>'id',type=>'int(11)',null=>'',key=>'PRI',default=>'',extra=>'auto_increment'
             },
            ],

);

# S2
my%fielddefinitions=(
    z3950servers=>
            [
             {field=>'id',type=>'int(11)',null=>'',key=>'PRI',default=>'',extra=>'auto_increment'
             },
            ],

);

==> b1025 <==
# S1
use Test::Requires {
     'DateTime' =>
              '0', };

# S2
use Test::Requires {
     'DateTime' =>
              '0', };

==> b1026 <==
# S1
use Test::Requires {
     'Locale::US' =>
       '0',
     'Regexp::Common'
       => '0',
};

# S2
use Test::Requires {
     'Locale::US' =>
       '0',
     'Regexp::Common'
       => '0',
};

==> b1027 <==
use Test::Requires {
    'Locale::US' =>
             '0',
    'Regexp::Common'
             => '0',
};


==> b1028 <==
use Test::Requires {
     'DBM::Deep' =>
'1.0003',
'DateTime::Format::MySQL'
              => '0',
};


==> b1029 <==
# S1
use Test::Requires {
    'Archive::Zip' =>
      0,
'Test::DependentModules'
      => '0.13',
    'MetaCPAN::API'
      => '0.33',
};

use Test::Requires {
    'Archive::Zip' =>
      0,
'Test::DependentModules'
      => '0.13',
    'MetaCPAN::API'
      => '0.33',
};


==> b103 <==
                        # State 1
                        my @tail = (
                                @buf[ ( $i % ( -$p ) + 1 )
                                  .. $#buf ],
                                @buf[ 0 .. $i % ( -$p ) ]
                        );

                        # State 2
                        my @tail = (
                                @buf[ ( $i % ( -$p ) + 1 )
                                  .. $#buf ],
                                @buf[ 0 .. $i % ( -$p ) ]
                        );

==> b1030 <==
use Test::Requires {
    'Types::Standard' =>
             0.021_03 };

use Test::Requires {
    'Types::Standard' =>
             0.021_03 };

==> b1031 <==
# S1
@EXPORT
  =(&INVALID_BOOLEAN_STRING_EXCEPTION
  );

# S2
@EXPORT
  =(&INVALID_BOOLEAN_STRING_EXCEPTION
  );

==> b1032 <==
    $a=1
      if(
        (   defined(
                $seq
                  [$current])
        )
        &&( $seq[$current]
            ->annotation
            ->each_Comment)
      );

    $a=1
      if(
        (   defined(
                $seq
                  [$current])
        )
        &&( $seq[$current]
            ->annotation
            ->each_Comment)
      );

    $a=1
      if(
        (   defined(
                $seq
                  [$current])
        )
        &&( $seq[$current]
            ->annotation
            ->each_Comment)
      );

==> b1033 <==
# S1
my @names =
        (
        qw(HV_DELETE HV_DISABLE_UVAR_XKEY HV_FETCH_ISSTORE
              HV_FETCH_ISEXISTS HV_FETCH_LVALUE HV_FETCH_JUST_SV
              G_SCALAR G_ARRAY G_VOID G_DISCARD G_EVAL G_NOARGS
              G_KEEPERR G_NODEBUG G_METHOD G_FAKINGEVAL
              GV_NOADD_NOINIT
              IS_NUMBER_IN_UV IS_NUMBER_GREATER_THAN_UV_MAX
              IS_NUMBER_NOT_INT IS_NUMBER_NEG IS_NUMBER_INFINITY
              IS_NUMBER_NAN IS_NUMBER_TRAILING PERL_SCAN_TRAILING
              PERL_LOADMOD_DENY PERL_LOADMOD_NOIMPORT PERL_LOADMOD_IMPORT_OPS
        ),
        { name => "G_WANT", default => [ "IV", "G_ARRAY|G_VOID" ] }
        );

# S2
my @names =
        (
        qw(HV_DELETE HV_DISABLE_UVAR_XKEY HV_FETCH_ISSTORE
              HV_FETCH_ISEXISTS HV_FETCH_LVALUE HV_FETCH_JUST_SV
              G_SCALAR G_ARRAY G_VOID G_DISCARD G_EVAL G_NOARGS
              G_KEEPERR G_NODEBUG G_METHOD G_FAKINGEVAL
              GV_NOADD_NOINIT
              IS_NUMBER_IN_UV IS_NUMBER_GREATER_THAN_UV_MAX
              IS_NUMBER_NOT_INT IS_NUMBER_NEG IS_NUMBER_INFINITY
              IS_NUMBER_NAN IS_NUMBER_TRAILING PERL_SCAN_TRAILING
              PERL_LOADMOD_DENY PERL_LOADMOD_NOIMPORT PERL_LOADMOD_IMPORT_OPS
        ),
        { name => "G_WANT", default => [ "IV", "G_ARRAY|G_VOID" ] }
        );

==> b1034 <==
        # S1
        $record =
          MARChtml2marc(
                         $dbh,             \@tags,
                         \@subfields,      \@values,
                         \@firstsubfields, \@indicator,
                         \@ind_tag
          );

        # S2
        $record =
          MARChtml2marc(
                         $dbh,             \@tags,
                         \@subfields,      \@values,
                         \@firstsubfields, \@indicator,
                         \@ind_tag
          );

==> b1035 <==
push @moreopts,
    INSTALLDIRS =>
    ( ( $] >= 5.005 and $] < 5.011 ) ? 'perl' :
        'site' ) ;

push @moreopts,
    INSTALLDIRS =>
    ( ( $] >= 5.005 and $] < 5.011 ) ? 'perl' :
        'site' ) ;


==> b1036 <==
        # State 1
        my @tests =
                (
                { file => 'simple',      name => 'Create empty', },
                { file => 'todo_inline', name => 'Passing TODO', },
                );

        # State 2
        my @tests =
                (
                { file => 'simple',      name => 'Create empty', },
                { file => 'todo_inline', name => 'Passing TODO', },
                );

==> b1036a <==
        my @tests =
                (
                { file => 'simple',      name => 'Create empty', },
                { file => 'todo_inline', name => 'Passing TODO', },
                );

        my @tests =
                (
                { file => 'simple',      name => 'Create empty', },
                { file => 'todo_inline', name => 'Passing TODO', },
                );

==> b1037 <==
# s1
my @cases =
        (
        [ 'Thwack', 'package Thwack; XSLoader::load(); 1' ],
        [ 'Zlott',  'package Thwack; XSLoader::load("Zlott"); 1' ],
        );

# s2
my @cases =
        (
        [ 'Thwack', 'package Thwack; XSLoader::load(); 1' ],
        [ 'Zlott',  'package Thwack; XSLoader::load("Zlott"); 1' ],
        );

==> b1038 <==
        # S1
        @_ =
                (
                join( " ",
                        sort @{ mro::get_isarev $args[0] } ),
                join( " ", sort @args[ 1 .. $#args - 1 ] ),
                pop @args
                );

        # S2
        @_ =
                (
                join( " ",
                        sort @{ mro::get_isarev $args[0] } ),
                join( " ", sort @args[ 1 .. $#args - 1 ] ),
                pop @args
                );


==> b1039 <==
# S1
Moose::Exporter
  ->setup_import_methods
  (
       as_is=>[qw(
                type subtype class_type role_type maybe_type duck_type
                as where message inline_as
                coerce from via
                enum union
                find_type_constraint
                register_type_constraint
                match_on_type )
       ],
  );

# S2
Moose::Exporter
  ->setup_import_methods
  (
       as_is=>[qw(
                type subtype class_type role_type maybe_type duck_type
                as where message inline_as
                coerce from via
                enum union
                find_type_constraint
                register_type_constraint
                match_on_type )
       ],
  );

==> b1040 <==
      # S1
      my $testport =
               ( Socket::unpack_sockaddr_in6 $testserver
                  ->sockname )[0] ;

      # S2
      my $testport =
               ( Socket::unpack_sockaddr_in6 $testserver
                  ->sockname )[0] ;

==> b1041 <==
               # S1
               $host
                  =(split
                       ( /[:. ]/,
`/com/host`,
                         6
                       ))
                  [0];

               # S2
               $host
                  =(split
                       ( /[:. ]/,
`/com/host`,
                         6
                       ))
                  [0];


==> b1042 <==
        # S1
        @_ =
                (
                join( " ",
                        sort @{ mro::get_isarev $args[0] } ),
                join( " ", sort @args[ 1 .. $#args - 1 ] ),
                pop @args
                );

        # S2
        @_ =
                (
                join( " ",
                        sort @{ mro::get_isarev $args[0] } ),
                join( " ", sort @args[ 1 .. $#args - 1 ] ),
                pop @args
                );

==> b1043 <==
        # S1
        my $addr =(
                DynaLoader::dl_find_symbol($handle,uc $prefix.$name)
                  ||DynaLoader::dl_find_symbol(
                          $handle, $prefix.$name
                  )
        );

        # S2

        my $addr =(
                DynaLoader::dl_find_symbol($handle,uc $prefix.$name)
                  ||DynaLoader::dl_find_symbol(
                          $handle, $prefix.$name
                  )
        );

==> b1044 <==
# S1
my @names =
        (
        qw(
                AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
                UIO_MAXIOV
        ),
        {name=>"IPPROTO_IP",type=>"IV",default=>["IV",   0]},
        {name=>"IPPROTO_IPV6",type=>"IV",default=>["IV",  41]},
        );

my @names =
        (
        qw(
                AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
                UIO_MAXIOV
        ),
        {name=>"IPPROTO_IP",type=>"IV",default=>["IV",   0]},
        {name=>"IPPROTO_IPV6",type=>"IV",default=>["IV",  41]},
        );

==> b1045 <==
# S1
my @bodies =
        (

        ['f99',                         1, 1, 0,qr/^$/,],
        ['$x=',                         0, 0, 0,qr/syntax error/,],
        );

# S2
my @bodies =
        (

        ['f99',                         1, 1, 0,qr/^$/,],
        ['$x=',                         0, 0, 0,qr/syntax error/,],
        );

==> b1046 <==
# S1
my @boolfunc =
        (
        {name => "Exclusion",type => "bool",hash => \%Exclus,},
        {name => "Singleton",type => "bool",hash => \%Single,},
        {name => "NonStDecomp",type => "bool",hash => \%NonStD,},
        );

# S2
my @boolfunc =
        (
        {name => "Exclusion",type => "bool",hash => \%Exclus,},
        {name => "Singleton",type => "bool",hash => \%Single,},
        {name => "NonStDecomp",type => "bool",hash => \%NonStD,},
        );

==> b1047 <==
        # S1
        @GZIP_OS_Names =
                (
                [ ''        => 0,  'MS-DOS' ],
                [ 'amigaos' => 1,  'Amiga' ],
                [ 'VMS'     => 2,  'VMS' ],
                [ ''        => 3,  'Unix/Default' ],
                [ ''        => 4,  'VM/CMS' ],
                [ ''        => 5,  'Atari TOS' ],
                [ 'os2'     => 6,  'HPFS (OS/2, NT)' ],
                [ 'MacOS'   => 7,  'Macintosh' ],
                [ ''        => 8,  'Z-System' ],
                [ ''        => 9,  'CP/M' ],
                [ ''        => 10, 'TOPS-20' ],
                [ ''        => 11, 'NTFS (NT)' ],
                [ ''        => 12, 'SMS QDOS' ],
                [ ''        => 13, 'Acorn RISCOS' ],
                [ 'MSWin32' => 14, 'VFAT file system (Win95, NT)' ],
                [ ''        => 15, 'MVS' ],
                [ 'beos'    => 16, 'BeOS' ],
                [ ''        => 17, 'Tandem/NSK' ],
                [ ''        => 18, 'THEOS' ],
                [ ''        => 255, 'Unknown OS' ],
                );

        # S2
        @GZIP_OS_Names =
                (
                [ ''        => 0,  'MS-DOS' ],
                [ 'amigaos' => 1,  'Amiga' ],
                [ 'VMS'     => 2,  'VMS' ],
                [ ''        => 3,  'Unix/Default' ],
                [ ''        => 4,  'VM/CMS' ],
                [ ''        => 5,  'Atari TOS' ],
                [ 'os2'     => 6,  'HPFS (OS/2, NT)' ],
                [ 'MacOS'   => 7,  'Macintosh' ],
                [ ''        => 8,  'Z-System' ],
                [ ''        => 9,  'CP/M' ],
                [ ''        => 10, 'TOPS-20' ],
                [ ''        => 11, 'NTFS (NT)' ],
                [ ''        => 12, 'SMS QDOS' ],
                [ ''        => 13, 'Acorn RISCOS' ],
                [ 'MSWin32' => 14, 'VFAT file system (Win95, NT)' ],
                [ ''        => 15, 'MVS' ],
                [ 'beos'    => 16, 'BeOS' ],
                [ ''        => 17, 'Tandem/NSK' ],
                [ ''        => 18, 'THEOS' ],
                [ ''        => 255, 'Unknown OS' ],
                );

==> b1048 <==
        # S1
        $titles
             .= ( $timestamp
                  ? format_date($timestamp)
                  : "" ) . ";";

        # S2
        $titles
             .= ( $timestamp
                  ? format_date($timestamp)
                  : "" ) . ";";

==> b1049 <==
            # s1
            $link.=
              (
                $link?'/':'')
              .'"'
              .$node
              .'"';

            # S2

            $link.=
              (
                $link?'/':'')
              .'"'
              .$node
              .'"';

==> b1050 <==
        #s1
        $uidl
                 =(
            $me->message
                     =~/\d+\s+([\041-\176]+)/
                 )[0];

        # s2
        $uidl
                 =(
            $me->message
                     =~/\d+\s+([\041-\176]+)/
                 )[0];


==> b1051 <==
        my @records=
                (
                {separator => '0',effective => '',text => 'ab'},
                {separator => ';',effective => ';',text => 'a;b'},
                ) ;

        my @records=
                (
                {separator => '0',effective => '',text => 'ab'},
                {separator => ';',effective => ';',text => 'a;b'},
                ) ;

==> b1052 <==
                        # S1
                        my ( $lname, $sname ) = (
                                $subname,
                                substr( $subname, 0,
                                        $maxflen - 3 )
                        );

                        #S2
                        my ( $lname, $sname ) = (
                                $subname,
                                substr( $subname, 0,
                                        $maxflen - 3 )
                        );

                        my ( $lname, $sname ) = (
                                $subname,
                                substr( $subname, 0,
                                        $maxflen - 3 )
                        );

==> b1053 <==
     $_++
            foreach
            sub :
            lvalue {
          %h =
                 ( $x,
               $x );
            }
            ->();

     $_++
            foreach
            sub :
            lvalue {
          %h =
                 ( $x,
               $x );
            }
            ->();

==> b1054 <==
    # S1
    $all_passed
      &= is( $fastc, $fastr,
             "right col tag should be bottom row tag" ) ;

    #S2
    $all_passed
      &= is( $fastc, $fastr,
             "right col tag should be bottom row tag" ) ;

    $all_passed
      &= is( $fastc, $fastr,
             "right col tag should be bottom row tag" ) ;

==> b1055 <==
      # S1
      my @tests =
        (   [$x],
            [ [ [
"aa",
"b",
"c"
                        ]
                  ]
                    =>
"SubField must have two parts"
            ],
        );

      # S2
      my @tests =
        (   [$x],
            [ [ [
"aa",
"b",
"c"
                        ]
                  ]
                    =>
"SubField must have two parts"
            ],
        );

==> b1056 <==
        # S1
        my$nt=
                 (
            $^O eq 'os2'
            ?
                     ''
            :'not');

        #S2
        my$nt=
                 (
            $^O eq 'os2'
            ?
                     ''
            :'not');

==> b1057 <==
       # S1
       is_deeply( [ [ OUT_STD, "Bail out!  foo bar baz\n" ] ],
       );

       # S2
       is_deeply( [ [ OUT_STD, "Bail out!  foo bar baz\n" ] ],
       );

==> b1057a <==
       is_deeply(
                 [
                   $it->halt_tap(
                                 {control => {details => 0}}
                   )
                 ],
                 [[OUT_STD, "Bail out!  0\n"]],
                 "falsy details"
       );

       is_deeply(
                 [
                   $it->halt_tap(
                                 {control => {details => 0}}
                   )
                 ],
                 [[OUT_STD, "Bail out!  0\n"]],
                 "falsy details"
       );

==> b1058 <==
# S1
like (
        exception {
               $params->parameterized (
                                  {
                                    a => 'Hello',
                                    b => 'World'
                                  } );
        },
);

#S2
like (
        exception {
               $params->parameterized (
                                  {
                                    a => 'Hello',
                                    b => 'World'
                                  } );
        },
);

==> b1059 <==
 # S1
 my($got)=
 ParseParameters(
      0,
      {
       'bufsize'=>
       [IO::Compress::Base::Common::Parse_unsigned,4096],
       'windowbits'=>
       [IO::Compress::Base::Common::Parse_signed,MAX_WBITS()],
       'dictionary'=>[IO::Compress::Base::Common::Parse_any,""],
      },
      @_
 );

 # S2

 my($got)=
 ParseParameters(
      0,
      {
       'bufsize'=>
       [IO::Compress::Base::Common::Parse_unsigned,4096],
       'windowbits'=>
       [IO::Compress::Base::Common::Parse_signed,MAX_WBITS()],
       'dictionary'=>[IO::Compress::Base::Common::Parse_any,""],
      },
      @_
 );

==> b106 <==
                                # State 1
                                my @tail =
                                  (
                                        @buf[ ( $i % ( -$p )
                                                  + 1 )
                                          .. $#buf ],
                                        @buf[ 0 .. $i % ( -$p )
                                        ] );

                                # State 2
                                my @tail = (
                                        @buf[ ( $i % ( -$p )
                                                  + 1 )
                                          .. $#buf ],
                                        @buf[ 0 .. $i % ( -$p )
                                        ] );

==> b1060 <==
# S1
my $lxy = ( @$cx - @$cy ) ||
  (
    length( int( $cx->[-1] ) ) -
    length( int( $cy->[-1] ) ) );

# S2
my $lxy = ( @$cx - @$cy ) ||
  (
    length( int( $cx->[-1] ) ) -
    length( int( $cy->[-1] ) ) );

==> b1061 <==
# S1
my @subnormals =
        (
        [ '1e-320', '%a', '0x1.fap-1064' ],
        [ '3e-324', '%.1a', '0x1.0p-1074' ],
        [
                '0x1.fffffffffffffp-1022', '%a',
                '0x1.fffffffffffffp-1022'
        ],
        [
                '0x0.fffffffffffffp-1022', '%a',
                '0x1.ffffffffffffep-1023'
        ],
        [
                '0x0.7ffffffffffffp-1022', '%a',
                '0x1.ffffffffffffcp-1024'
        ],
        [
                '0x0.3ffffffffffffp-1022', '%a',
                '0x1.ffffffffffff8p-1025'
        ],
        [
                '0x0.1ffffffffffffp-1022', '%a',
                '0x1.ffffffffffffp-1026'
        ],
        [
                '0x0.0ffffffffffffp-1022', '%a',
                '0x1.fffffffffffep-1027'
        ],
        );

# S2
my @subnormals =
        (
        [ '1e-320', '%a', '0x1.fap-1064' ],
        [ '3e-324', '%.1a', '0x1.0p-1074' ],
        [
                '0x1.fffffffffffffp-1022', '%a',
                '0x1.fffffffffffffp-1022'
        ],
        [
                '0x0.fffffffffffffp-1022', '%a',
                '0x1.ffffffffffffep-1023'
        ],
        [
                '0x0.7ffffffffffffp-1022', '%a',
                '0x1.ffffffffffffcp-1024'
        ],
        [
                '0x0.3ffffffffffffp-1022', '%a',
                '0x1.ffffffffffff8p-1025'
        ],
        [
                '0x0.1ffffffffffffp-1022', '%a',
                '0x1.ffffffffffffp-1026'
        ],
        [
                '0x0.0ffffffffffffp-1022', '%a',
                '0x1.fffffffffffep-1027'
        ],
        );

==> b1062 <==
    # S1
    my $search_re =
             ( $self->opt_f =~
                /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/ )
             ? '(?:I<)?-X'
             : quotemeta( $self->opt_f );

    # S2
    my $search_re =
             ( $self->opt_f =~
                /^-[rwxoRWXOeszfdlpSbctugkTBMAC]$/ )
             ? '(?:I<)?-X'
             : quotemeta( $self->opt_f );

==> b1063 <==
   # S1
   my ($got) =
     ParseParameters(
             0,
             {
                'bufsize' =>
                [ IO::Compress::Base::Common::Parse_unsigned, 4096 ],
                'windowbits' => [
                                  IO::Compress::Base::Common::Parse_signed,
                                  MAX_WBITS()
                ],
                'dictionary' =>
                [ IO::Compress::Base::Common::Parse_any, "" ],
             },
             @_
     );

   # S2
   my ($got) =
     ParseParameters(
             0,
             {
                'bufsize' =>
                [ IO::Compress::Base::Common::Parse_unsigned, 4096 ],
                'windowbits' => [
                                  IO::Compress::Base::Common::Parse_signed,
                                  MAX_WBITS()
                ],
                'dictionary' =>
                [ IO::Compress::Base::Common::Parse_any, "" ],
             },
             @_
     );

==> b1064 <==
    # S1
    is_deeply(
      [[OUT_STD, "ok 1 - bob\n"]],
      "Parent (un-buffered)",
    );

    # S2
    is_deeply(
      [[OUT_STD, "ok 1 - bob\n"]],
      "Parent (un-buffered)",
    );

==> b1065 <==
# S1:
sub VerifyData
     {

         my $hashref
              = shift;
         if (     !ok(     keys
                                (   %bad
                                )
                                +
                                keys
                                (   %expected
                                )
                                ==
                                0
                           ,
"Expected == Actual"
                  )
              )
              {
                  my $bad
                       =
"Expected does not match actual\n";
              }
     }

# S2: (changed name to avoid error message)
sub VerifyDatA
     {

         my $hashref
              = shift;
         if (     !ok(     keys
                                (   %bad
                                )
                                +
                                keys
                                (   %expected
                                )
                                ==
                                0
                           ,
"Expected == Actual"
                  )
              )
              {
                  my $bad
                       =
"Expected does not match actual\n";
              }
     }

==> b1066 <==
    my ($seq,
        $id,
        $acc,
        $pid,
        $desc,
        $moltype,
        $given_id,
        $is_reference,
        $repeat_unit,
        $repeat_count
      )
      = $self
      ->_rearrange
      ([
            qw(SEQ
				 DISPLAY_ID
				 ACCESSION_NUMBER
				 PRIMARY_ID
				 DESC
				 MOLTYPE
				 ID
				 IS_REFERENCE
				 REPEAT_UNIT
				 REPEAT_COUNT
				 )
        ],
        @args
      );

==> b1067 <==
    (
        $var1,

      ) =
      $self
      ->_rearrange
      ( [
            qw(FH
                              ROUND
                    )
        ],
        @args
      );

==> b1068 <==
# S1
my @testsubs =
     (
          sub {
               like ( $@,
                      qr/locate object method/ );
          },
          sub {
'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
          },
     );

# S2
my @testsubs =
     (
          sub {
               like ( $@,
                      qr/locate object method/ );
          },
          sub {
'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
          },
     );

==> b1069 <==
         # S1
         my $res = [
                  _process_typemaps(
                           [@local_tmaps],
                           '.' )
         ];

         # S2
         my $res = [
                  _process_typemaps(
                           [@local_tmaps],
                           '.' )
         ];

==> b1070 <==
       # S1
       my $res = [
              _process_typemaps(
                     [@local_tmaps], '.' )
       ];

       # S2
       my $res = [
              _process_typemaps(
                     [@local_tmaps], '.' )
       ];

==> b1071 <==
    # S1
    my ($seq,) =
      $self
      ->_rearrange
      ([
            qw(SEQ
                              SEQORI
                    )
        ],
        @args
      );

    # S2
    my ($seq,) =
      $self
      ->_rearrange
      ([
            qw(SEQ
                              SEQORI
                    )
        ],
        @args
      );

==> b1072 <==
%XS_TypeSet =
     (
        IV  => '*iv_return = ',
        UV  => '*iv_return = (IV)',
        NV  => '*nv_return = ',
        PV  => '*pv_return = ',
        PVN => [
                '*pv_return = ',
                '*iv_return = (IV)'
        ],
        SV    => '*sv_return = ',
        YES   => undef,
        NO    => undef,
        UNDEF => undef,
     );

%XS_TypeSet =
     (
        IV  => '*iv_return = ',
        UV  => '*iv_return = (IV)',
        NV  => '*nv_return = ',
        PV  => '*pv_return = ',
        PVN => [
                '*pv_return = ',
                '*iv_return = (IV)'
        ],
        SV    => '*sv_return = ',
        YES   => undef,
        NO    => undef,
        UNDEF => undef,
     );

==> b1073 <==
# Keeps adding a blank line!!
    sub stop {


        1;
    }

    sub start {


        1;
    }


==> b1074 <==
        (
            $PhoneDateLog,
            $PhoneTimeLog,
            $PhoneNameLog,
            $PhoneNumberLog
             )
             = (
            split('`',
                $CallLogTempLine
            ))[ 0, 1,
             2, 3 ];

==> b1075 <==
          my (@to_push)
               = (
               split(/\|/,
                    $_[FILE_NAME])
               )
               [@push_inx
               ];

          my (@to_push)
               = (
               split(/\|/,
                    $_[FILE_NAME])
               )
               [@push_inx
               ];


==> b1076 <==
$Locale::Codes::Retired{'langext'}{'alpha'}
    {'name'} =
    {
       q(hawai'i pidgin sign language) => [
           q(hps), q(Hawai'i Pidgin Sign Language)
       ],
       q(rennellese sign language) =>
       [ q(rsi), q(Rennellese Sign Language) ],
       q(yiddish sign language) =>
       [ q(yds), q(Yiddish Sign Language) ],
    };

$Locale::Codes::Retired{'langext'}{'alpha'}
    {'name'} =
    {
       q(hawai'i pidgin sign language) => [
           q(hps), q(Hawai'i Pidgin Sign Language)
       ],
       q(rennellese sign language) =>
       [ q(rsi), q(Rennellese Sign Language) ],
       q(yiddish sign language) =>
       [ q(yds), q(Yiddish Sign Language) ],
    };

==> b1077 <==
    foreach
      my $key(
        sort(keys(%{$self->{data}}))
      )
__END__

    foreach my $key(
          sort(
               keys(%{$self->{data}}))
      )


==> b1078 <==
if ( not (
       ok scalar (
              grep { ref $_ and $_->can ('type') }
                @t ) => 16 ) )

  if ( not (
       ok scalar (
              grep { ref $_ and $_->can ('type') }
                @t ) => 16 ) )

==> b1079 <==
    my ( $id,
        $sysname,
        $aa_mut )
      = $self
      ->_rearrange
      ( [
            qw(ID
				 AA_MUT
				 )
        ],
        @args
      );

    my ( $id,
        $sysname,
        $aa_mut )
      = $self
      ->_rearrange
      ( [
            qw(ID
				 AA_MUT
				 )
        ],
        @args
      );


==> b1080 <==
    my ($seq,
        $id,
      )
      = $self
      ->_rearrange
      ([
            qw(SEQ
			      ID
			      )
        ],
        @args
      );

==> b1081 <==
   @apple_encs
     = (
      <<'EOT',
M>)RES==NCW$`@.'G_S5Q*L(!#?+K1VO4:.W6IJA-:\^BM?>L>1&NP(A0Q$BL
EOT
      undef,
      <<'EOT',
M>)RES[=/%```1O$WO8G_@$'J';W70Z2WHS>5WJN%8D6%D;BZ,3*P,;#C2D(8
EOT
     );

   @apple_encs
     = (
      <<'EOT',
M>)RES==NCW$`@.'G_S5Q*L(!#?+K1VO4:.W6IJA-:\^BM?>L>1&NP(A0Q$BL
EOT
      undef,
      <<'EOT',
M>)RES[=/%```1O$WO8G_@$'J';W70Z2WHS>5WJN%8D6%D;BZ,3*P,;#C2D(8
EOT
     );

==> b1082 <==
                return map{
                    ($_,[$self->$_(@_[1..$#_])])
                }@every;

                return map{
                    ($_,[$self->$_(@_[1..$#_])])
                }@every;

==> b1083 <==
                        $replaced_okay =
                          (
                             $path =~ s#^(.*)$malldir\.pm\z#$1auto:$malldir:autosplit.ix#s );

                        $replaced_okay =
                          (
                             $path =~ s#^(.*)$malldir\.pm\z#$1auto:$malldir:autosplit.ix#s );

==> b1084 <==
     my ($RANGE,
          $LHS,
          $TYPE,
          $RHS)
          = (
          split(/\s+/,
               $GENERATE))
          [ 1 .. 4
          ];

     my ($RANGE,
          $LHS,
          $TYPE,
          $RHS)
          = (
          split(/\s+/,
               $GENERATE))
          [ 1 .. 4
          ];

==> b1085 <==
$term =
     Tgetent
     Term::Cap
     {
     'TERM' => '',
     'OSPEED' =>
          $ospeed
     };

$term =
     Tgetent
     Term::Cap
     {
     'TERM' => '',
     'OSPEED' =>
          $ospeed
     };


==> b1086 <==
     my ($GPSTime,
          $GPSLatitude,
          $GPSLongitude,
          $GPSSpeed,
          $GPSCourse)
          = (
          split(',',
               $data))[ 1, 3,
          5, 7,
          8 ];

     my ($GPSTime,
          $GPSLatitude,
          $GPSLongitude,
          $GPSSpeed,
          $GPSCourse)
          = (
          split(',',
               $data))[ 1, 3,
          5, 7,
          8 ];


==> b1087 <==
        $out = join(
            ' ',
            map {
                sprintf(
                    "%02X",
                    ord($_) )
            } (
                split( '',
                    substr( $dat,
                        $i,
                        16 ) ) )
        );

        $out = join(
            ' ',
            map {
                sprintf(
                    "%02X",
                    ord($_) )
            } (
                split( '',
                    substr( $dat,
                        $i,
                        16 ) ) )
        );

==> b1087a <==
          $out = join(
               ' ',
               map {
                    sprintf(
                         "%02X",
                         ord($_))
               } (
                    split('',
                         substr($dat,
                              $i,
                              16)))
          );

          $out = join(
               ' ',
               map {
                    sprintf(
                         "%02X",
                         ord($_))
               } (
                    split('',
                         substr($dat,
                              $i,
                              16)))
          );

==> b1088 <==
               $domain_name
                    = (
                    split(' ',
                         $answer))[4];

               $domain_name
                    = (
                    split(' ',
                         $answer))[4];

==> b1089 <==
       my %args = (
              'for' => "Foo::Role" );

       my %args = (
              'for' => "Foo::Role" );

==> b109 <==
              do {
                     push @keys,
                       [
                            curr_opt (
                                   @beg[ 2,
                                     5 ] ),
                            1,
                            @beg[ 0, 1, 3,
                              4 ] ];
              }

==> b1090 <==
     my %handles = (
          count        => 'count',
          elements     => 'elements',
          is_empty     => 'is_empty',
          push         => 'push',
          push_curried => [ push => 42, 84 ],
          unshift      => 'unshift',
          unshift_curried =>
                 [ unshift => 42, 84 ],
          pop           => 'pop',
          shift         => 'shift',
          get           => 'get',
          get_curried   => [ get => 1 ],
          set           => 'set',
          set_curried_1 => [ set => 1 ],
          set_curried_2 =>
                 [ set => ( 1, 98 ) ],
          accessor           => 'accessor',
          accessor_curried_1 =>
                 [ accessor => 1 ],
          accessor_curried_2 =>
                 [ accessor => ( 1, 90 ) ],
          clear          => 'clear',
          delete         => 'delete',
          delete_curried => [ delete => 1 ],
          insert         => 'insert',
          insert_curried =>
                 [ insert => ( 1, 101 ) ],
          splice           => 'splice',
          splice_curried_1 => [ splice => 1 ],
          splice_curried_2 =>
                 [ splice => 1, 2 ],
          splice_curried_all => [
               splice => 1,
               2, ( 3, 4, 5 )
          ],
          sort         => 'sort',
          sort_curried =>
                 [
               sort => ( sub { $_[1] <=> $_[0] } )
                 ],
          sort_in_place => 'sort_in_place',
          sort_in_place_curried =>
                 [
               sort_in_place =>
                      ( sub { $_[1] <=> $_[0] } )
                 ],
          map         => 'map',
          map_curried =>
                 [
               map => ( sub { $_ + 1 } ) ],
          grep         => 'grep',
          grep_curried =>
                 [
               grep => ( sub { $_ < 5 } ) ],
          first         => 'first',
          first_curried =>
                 [
               first => ( sub { $_ % 2 } ) ],
          first_index => 'first_index',
          first_index_curried =>
                 [
               first_index => ( sub { $_ % 2 } ) ],
          join           => 'join',
          join_curried   => [ join => '-' ],
          shuffle        => 'shuffle',
          uniq           => 'uniq',
          reduce         => 'reduce',
          reduce_curried =>
                 [
               reduce => ( sub { $_[0] * $_[1] } )
                 ],
          natatime         => 'natatime',
          natatime_curried =>
                 [ natatime => 2 ],
     );

     my %handles = (
          count        => 'count',
          elements     => 'elements',
          is_empty     => 'is_empty',
          push         => 'push',
          push_curried => [ push => 42, 84 ],
          unshift      => 'unshift',
          unshift_curried =>
                 [ unshift => 42, 84 ],
          pop           => 'pop',
          shift         => 'shift',
          get           => 'get',
          get_curried   => [ get => 1 ],
          set           => 'set',
          set_curried_1 => [ set => 1 ],
          set_curried_2 =>
                 [ set => ( 1, 98 ) ],
          accessor           => 'accessor',
          accessor_curried_1 =>
                 [ accessor => 1 ],
          accessor_curried_2 =>
                 [ accessor => ( 1, 90 ) ],
          clear          => 'clear',
          delete         => 'delete',
          delete_curried => [ delete => 1 ],
          insert         => 'insert',
          insert_curried =>
                 [ insert => ( 1, 101 ) ],
          splice           => 'splice',
          splice_curried_1 => [ splice => 1 ],
          splice_curried_2 =>
                 [ splice => 1, 2 ],
          splice_curried_all => [
               splice => 1,
               2, ( 3, 4, 5 )
          ],
          sort         => 'sort',
          sort_curried =>
                 [
               sort => ( sub { $_[1] <=> $_[0] } )
                 ],
          sort_in_place => 'sort_in_place',
          sort_in_place_curried =>
                 [
               sort_in_place =>
                      ( sub { $_[1] <=> $_[0] } )
                 ],
          map         => 'map',
          map_curried =>
                 [
               map => ( sub { $_ + 1 } ) ],
          grep         => 'grep',
          grep_curried =>
                 [
               grep => ( sub { $_ < 5 } ) ],
          first         => 'first',
          first_curried =>
                 [
               first => ( sub { $_ % 2 } ) ],
          first_index => 'first_index',
          first_index_curried =>
                 [
               first_index => ( sub { $_ % 2 } ) ],
          join           => 'join',
          join_curried   => [ join => '-' ],
          shuffle        => 'shuffle',
          uniq           => 'uniq',
          reduce         => 'reduce',
          reduce_curried =>
                 [
               reduce => ( sub { $_[0] * $_[1] } )
                 ],
          natatime         => 'natatime',
          natatime_curried =>
                 [ natatime => 2 ],
     );

==> b1091 <==
   foreach (@sigs)
   {    # Don't allow interruptions
      $SIG{$_} = 'IGNORE';
   }
   ( open(
      CHECKPOINT, "> $aub_tmp"
   ) )
     ||    # This is just temporary...
     &abort(
"Could not open temporary file $aub_tmp for writing"
     );

   foreach (@sigs)
   {       # Don't allow interruptions
      $SIG{$_} = 'IGNORE';
   }
   ( open(
      CHECKPOINT, "> $aub_tmp"
   ) )
     ||    # This is just temporary...
     &abort(
"Could not open temporary file $aub_tmp for writing"
     );

==> b1092 <==
        foreach$at(
            grep ($_->Removeable==1,
                  @{
                      $self->Target->AttribBox
                        ->Attrib
                  })
          )

__END__

        foreach$at(
            grep ($_->Removeable==1,
                  @{
                      $self->Target->AttribBox
                        ->Attrib
                  })
          )

==> b1093 <==
        foreach$at(
            grep ($_->Removeable==
                  1,
                @{$self->Target
                      ->AttribBox
                      ->Attrib})
          )

__END__

        foreach
          $at(grep
        ($_->Removeable==1,
            @{
                $self->Target
                  ->AttribBox
                  ->Attrib
            }))

==> b1094 <==
    foreach$thing(
               grep($_->Owner==
                     $self->Caster,
                   @{
                       $self->Arena
                         ->Monsters
                   })
      )

__END__
    foreach$thing(
               grep($_->Owner==
                     $self->Caster,
                   @{
                       $self->Arena
                         ->Monsters
                   })
      )


==> b1095 <==
        use Moose -traits=>
            [
             'My::Trait'=>
             {-alias=>{reversed_name=>'reversed',},-excludes=>'reversed_name',},
            ];

        use Moose -traits=>
            [
             'My::Trait'=>{
                           -alias=>{reversed_name=>'reversed',},
                           -excludes=>'reversed_name',
             },
            ];

==> b1096 <==
   use Moose -traits =>
     [
       'My::Trait' =>{
                      -alias => {reversed_name => 'reversed',},
                      -excludes => 'reversed_name',
       },
     ];

   use Moose -traits =>
     [
       'My::Trait' =>{
                      -alias => {reversed_name => 'reversed',},
                      -excludes => 'reversed_name',
       },
     ];


==> b1097 <==
          my (@files) =
                  @{ $args{-files}
                  };

          my (@files) =
                  @{ $args{-files}
                  };


==> b1098 <==
sub receive_bgp_update_message {
       my ( $peerref, $buff, $rtref, $my_ip ) = @_;
       if ( $unfeas_routes_len > 0 ) {
              foreach $route (@routes) {
                     my $prefix_length = $route->{prefix_length};
                     if ( $prefix_length == 0 ) {
       my $routecount = delete_all_routes( $rtref, $peer );
                     }
                     else {
       if ( delete_adjRIBin_route(
              $rtref, $prefix, $prefix_length, $peer
       ) )
       {
              ...;
       }
                     }
              }
       }
}
__END__
sub receive_bgp_update_message {
       my ( $peerref, $buff, $rtref, $my_ip ) = @_;
       if ( $unfeas_routes_len > 0 ) {
              foreach $route (@routes) {
                     my $prefix_length = $route->{prefix_length};
                     if ( $prefix_length == 0 ) {
       my $routecount = delete_all_routes( $rtref, $peer );
                     }
                     else {
       if ( delete_adjRIBin_route(
              $rtref, $prefix, $prefix_length, $peer
       ) )
       {
              ...;
       }
                     }
              }
       }
}

==> b1099 <==
# S1
     has observers =>
         ( traits     => ['Array'],
           is         => 'ro',
           isa        => 'ArrayRef[Observer]',
           auto_deref => 1,
           default    => sub { [] },
           handles    =>
           {     'add_observer'    => 'push',
                 'count_observers' => 'count', }, ) ;

# S2
     has observers =>
         ( traits     => ['Array'],
           is         => 'ro',
           isa        => 'ArrayRef[Observer]',
           auto_deref => 1,
           default    => sub { [] },
           handles    =>
           {     'add_observer'    => 'push',
                 'count_observers' => 'count', }, ) ;

==> b1100 <==
# S1
my $parent_sets = [
        [
                [qw( blue blue blue blue )],
                [
qw( blue blue blue blue )
                ] => 'blue'
        ], [
                [qw( blue blue blue blue )],
                [
qw( brown brown green blue )
                ] => 'brown'
        ], [
                [
qw( blue blue green green )
                ], [
qw( blue blue green green )
                ] => 'green'
        ], ];

# S2:
my $parent_sets = [
        [
                [qw( blue blue blue blue )],
                [
qw( blue blue blue blue )
                ] => 'blue'
        ], [
                [qw( blue blue blue blue )],
                [
qw( brown brown green blue )
                ] => 'brown'
        ], [
                [
qw( blue blue green green )
                ], [
qw( blue blue green green )
                ] => 'green'
        ], ];

==> b1101 <==
       %table =
               (
                  'title'       => 'Page Referrals by Referrals',
                  'col_headers' => [
                                     'Page',
                                     'First Referral',
                                     'Last Referrals',
                                     'Total Referrals'
                  ],
                  'data' => [@data]
               );

       %table =
               (
                  'title'       => 'Page Referrals by Referrals',
                  'col_headers' => [
                                     'Page',
                                     'First Referral',
                                     'Last Referrals',
                                     'Total Referrals'
                  ],
                  'data' => [@data]
               );


==> b1102 <==
sub generate_manifest_pod{
    generate_manifest
      map{[
           "pod/$_.pod",$state->{pods}{$_}
      ]}sort grep{
            !$state->{copies}{"$_.pod"}
          &&!$state->{generated}{"$_.pod"}
          &&!-e"$_.pod"
      }keys%{$state->{pods}};
}

# S2: changed sub name to avoid perltidy complaint
sub generate_manifest_poD{
    generate_manifest
      map{
        ["pod/$_.pod",$state->{pods}{$_}]
      }sort grep{
            !$state->{copies}{"$_.pod"}
          &&!$state->{generated}{"$_.pod"}
          &&!-e"$_.pod"
      }keys%{$state->{pods}};
}

==> b1103 <==
# Note that this has a -norecombine in the .par file

   # S1
   $data = {
             map { split ( '=', $_ ) }
                      split (
                              ' ', $2
                      )
   };

   # S2
   $data = {
             map { split ( '=', $_ ) }
                      split (
                              ' ', $2
                      )
   };

==> b1104 <==
foreach $port (
    sort ( @ARGV[ 1 .. $#ARGV ] ) )

__END__
foreach $port (
    sort ( @ARGV[ 1 .. $#ARGV ]
    ) )


==> b1105 <==
foreach $port (
    sort
         (
        @ARGV[ 1 .. $#ARGV ] )
     )
__END__
foreach $port (
    sort
    ( @ARGV[ 1 .. $#ARGV ]
    ) )


==> b1106 <==
                return
                      map{(
                     $_,[$self->$_(@_[1..$#_])])}@every;

                return
                      map{(
                     $_,[$self->$_(@_[1..$#_])])}@every;

==> b1107 <==
sub parsedate {
       if ($xx) {
              while (1) {
                     if (       !defined $m ) #
                     {

       if(&parse_date_offset(
              \$t,$now,\$y,\$m,\$d,\$rd,\$rs,%options
       ))
       {
              ...;
       }

                     }
              }
       }
}

==> b1108 <==
        my$clist=
          $scrolled_window_hash{
            (
                sort (
                    keys(%scrolled_window_hash))
            )[$page]
          }[1];

        my$clist=
          $scrolled_window_hash{
            (
                sort (
                    keys(%scrolled_window_hash))
            )[$page]
          }[1];

==> b1109 <==
ok(
    $original,
    "loaded "
      . basename $path
);

==> b1110 <==
                        $res .= $1;
                        last unless $3;
                        $res .=
                          depod1(
                                $rstr, $3,
                                closing $4 );

                        $res .= $1;
                        last unless $3;
                        $res .=
                          depod1(
                                $rstr, $3,
                                closing $4 );

==> b1111 <==
          my($name,$content)=
            map{@$_;}
            grep{$_->[0]eq$find}map{[### full path ###
           File::Spec::Unix->catfile(
                                     grep{length}@{$_->[0]},
                                     $_->[1]
           ),
           $_->[2],
            ]}@$struct;

          my($name,$content)=
            map{@$_;}
            grep{$_->[0]eq$find}map{[### full path ###
           File::Spec::Unix->catfile(
                                     grep{length}@{$_->[0]},
                                     $_->[1]
           ),
           $_->[2],
            ]}@$struct;


==> b1112 <==
run_tests(
        'Basic Big5 range',
        {
           'utf' => (
               24093.39640.38525.20043.33495.35028.20846.65292
                 . 26389.30343.32771.26352.20271.24248.65108
                 . 25885.25552.35998.20110.23391.38508.20846.65292
                 . 24799.24218.23493.21566.20197.38477.65108
           ),

           'big5-hkscs' => (
               join('',
']ABeQ',
's_sAG^HQ',
               )
           ),
        }
);

run_tests(
        'Basic Big5 range',
        {
           'utf' => (
               24093.39640.38525.20043.33495.35028.20846.65292
                 . 26389.30343.32771.26352.20271.24248.65108
                 . 25885.25552.35998.20110.23391.38508.20846.65292
                 . 24799.24218.23493.21566.20197.38477.65108
           ),

           'big5-hkscs' => (
               join('',
']ABeQ',
's_sAG^HQ',
               )
           ),
        }
);

==> b1113 <==
$STYLESHEET{'html-light'}={
    'tags'=>{
        'predefined identifier'=>
                 {
            'start'=>'<font color="#2040a0"><strong>',
            'stop'=>'</strong></font>'
                 },
    }
};

$STYLESHEET{'html-light'}={
    'tags'=>{
        'predefined identifier'=>
                 {
            'start'=>'<font color="#2040a0"><strong>',
            'stop'=>'</strong></font>'
                 },
    }
};

==> b1114 <==
is(
        length(pack("j",
                        0
        )),
        $Config{ivsize}
);

is(
        length(pack("j",
                        0
        )),
        $Config{ivsize}
);

==> b1115 <==
    return sort map{
        ($_,db_complete($_."::","v ",2))
      }

      return
      sort map{(
            $_,db_complete($_."::","v ",2))}


==> b1116 <==
sub checkorder{
        my ($i,
                $disorder);

        for ($i = 0;
                $i < $#$aref;
                ++$i)
        {
# Equality shouldn't happen, but catch it in the contents check

                $disorder =
                    (
                        substr(
                                $aref->[$i], 0,
                                $RootWidth) eq
                            substr(
                                $aref->[ $i +1 ],
                                0,
                                $RootWidth))
                    ? "Instability"
                    : "Disorder";
        }
}
__END__

sub checkorder{
        my ($i,
              $disorder);

        for ($i = 0;
              $i < $#$aref;
              ++$i)
        {
# Equality shouldn't happen, but catch it in the contents check

                $disorder =
                    (
                      substr(
                              $aref->[$i], 0,
                              $RootWidth
                      ) eq substr(
                               $aref->[ $i + 1 ],
                               0,
                               $RootWidth
                      )
                    )
                    ? "Instability"
                    : "Disorder";
        }
}

==> b1117 <==
is_deeply(
      $feature->prereqs->as_string_hash,
      {
      develop=>{
        requires=>{'Genius::Evil'=>'1.234'}
      },
      runtime=>{
      requires=>{'Machine::Weather'=>'2.0'}
      },
      },
      '$feature->prereqs',
);

is_deeply(
      $feature->prereqs->as_string_hash,
      {
      develop=>{
        requires=>{'Genius::Evil'=>'1.234'}
      },
      runtime=>{
      requires=>{'Machine::Weather'=>'2.0'}
      },
      },
      '$feature->prereqs',
);

is_deeply(
         $feature->prereqs->as_string_hash,
         {
          develop => {
              requires =>
              { 'Genius::Evil' => '1.234' }
          },
          runtime => {
            requires =>
            { 'Machine::Weather' => '2.0' }
          },
         },
         '$feature->prereqs',
);

==> b1118 <==
{
        my %tests = (
                -8589934592 =>
                    [   9,
                        -203,
qr/Oct \d+ .* 1697$/
                    ],
                -1296000 => [ 11,
                        69,
qr/Dec \d+ .* 1969$/
                ],
        );
}

{
        my %tests = (
                -8589934592 =>
                    [   9,
                        -203,
qr/Oct \d+ .* 1697$/
                    ],
                -1296000 => [ 11,
                        69,
qr/Dec \d+ .* 1969$/
                ],
        );
}

==> b1119 <==
 ok keys(%expected)+
         keys(%bad)==0,
"Raw hash is ok";

 ok keys(%expected)+
         keys(%bad)==0,
"Raw hash is ok";

==> b1120 <==
 ok
         exists{
  ____=>undef
         }->{$dummy},
'ref sets UTF8 flag correctly';

 ok
         exists{
  ____=>undef
         }->{$dummy},
'ref sets UTF8 flag correctly';

==> b1121 <==
%Expect_Dir = (
        dir_path(
                'fa') => 1,
        dir_path( 'fa',
                'faa' ) => 1,
        dir_path( 'fa',
                'fab' ) => 1,
        dir_path( 'fa',
                'fab',
                'faba' ) => 1,
        dir_path(
                'fb') => 1,
        dir_path( 'fb',
                'fba' ) => 1
);

%Expect_dir = (
        dir_path(
                'fa') => 1,
        dir_path( 'fa',
                'faa' ) => 1,
        dir_path( 'fa',
                'fab' ) => 1,
        dir_path( 'fa',
                'fab',
                'faba' ) => 1,
        dir_path(
                'fb') => 1,
        dir_path( 'fb',
                'fba' ) => 1
);

==> b1122 <==
                my @prog =
                    (
                        make_perl_prog(
                                $test,
                                $tests->{$test},
                                0),
                        make_perl_prog(
                                $test,
                                $tests->{$test},
                                1),
                    ) ;

                my @prog =
                    (
                        make_perl_prog(
                                $test,
                                $tests->{$test},
                                0),
                        make_perl_prog(
                                $test,
                                $tests->{$test},
                                1),
                    ) ;

==> b1123 <==
sub t025 (
    $ = undef )
{
    $a // "z";
}

sub t025 (
    $ = undef )
{
    $a // "z";
}

==> b1124 <==
         ok(
              ( $k, $err ) =
                new Compress::Raw::Zlib::Inflate( {
                                         -Bufsize      => 1,
                                         -AppendOutput => 1,
                                         -WindowBits => -MAX_WBITS()
                } )
         );

         ok(
              ( $k, $err ) =
                new Compress::Raw::Zlib::Inflate( {
                                         -Bufsize      => 1,
                                         -AppendOutput => 1,
                                         -WindowBits => -MAX_WBITS()
                } )
         );

==> b1125 <==
sub buffered {

}

# S1
my $buffered_shallow
  = intercept
{
    buffered
'buffered shallow'
      => $subtest
};

# S2
my $buffered_shallow
  = intercept
{
    buffered
'buffered shallow'
      => $subtest
};

==> b1126 <==
sub buffered {

}

# S1

my $buffered_shallow
  = intercept {
    buffered
'buffered shallow'
      => $subtest
  };

# S2
my $buffered_shallow
  = intercept {
    buffered
'buffered shallow'
      => $subtest
  };

==> b1127 <==
sub buffered
{

}

# S1
my $buffered_shallow
  = intercept
{
    buffered
'buffered shallow'
      =>
      $subtest
};

# S2

my $buffered_shallow
  = intercept
{
    buffered
'buffered shallow'
      =>
      $subtest
};

==> b1128 <==
is_deeply(
    [
        pairmap
          { uc
              $a
              =>
              $b
          }
    ]
);

is_deeply(
    [
        pairmap
          { uc
              $a
              =>
              $b
          }
    ]
);

==> b1129 <==
if ($ON_EBCDIC)
{      delete @Encode::ExtModule{
              qw(euc-cn gb2312 gb12345 gbk cp936 iso-ir-165 MacChineseSimp
                      euc-jp iso-2022-jp 7bit-jis shiftjis MacJapanese cp932
                      euc-kr ksc5601 cp949 MacKorean
                      big5	big5-hkscs cp950 MacChineseTrad
                      gb18030 big5plus euc-tw)
       };
}

==> b1130 <==
my @cases =
  (   { no_proxy => [ undef,       [], ],            expect => [], },
      { no_proxy => [ "localhost", ["localhost"], ], expect => ["localhost"], },
      {   no_proxy =>
          [ "localhost,example.com", "localhost, example.com", [qw/localhost example.com/] ],
          expect => [ "localhost", "example.com" ], },
  );

==> b1131 <==
is(
       j(
              splice(@a,-@a,@a,1,
                     2,3)
       ),
       j(0..13),
'splice the whole list out, add 3 elements, return value is @a'
);

is(
       j(
              splice(@a,-@a,@a,1,
                     2,3)
       ),
       j(0..13),
'splice the whole list out, add 3 elements, return value is @a'
);


==> b1132 <==
   my @temp =
     unexpand(
        map { sprintf "%-32s%s", @$_ } @_ );

   my @temp =
     unexpand(
        map { sprintf "%-32s%s", @$_ } @_ );


==> b1133 <==
            $pid=open README,"$html_converter $saved_file |"
              or
              $CPAN::Frontend->mydie(qq{
Could not fork '$html_converter $saved_file': $!});

            $pid=open README,"$html_converter $saved_file |"
              or
              $CPAN::Frontend->mydie(qq{
Could not fork '$html_converter $saved_file': $!});

==> b1134 <==
{
       ok do{
              grep {$_ eq $lib}
                @INC[0..(
                       $#INC-1)
                ]  ;
         },
'Identified entry in @INC';
}

{
       ok do{
              grep {$_ eq $lib}
                @INC[0..(
                       $#INC-1)
                ]  ;
         },
'Identified entry in @INC';
}

==> b1135 <==
{
    ok do{
        grep {$_ eq$lib}
          @INC[0..(
              $#INC-1)
          ]  ;
      },
'Identified entry in @INC with double colons';
}  ;

{
    ok do{
        grep {$_ eq$lib}
          @INC[0..(
              $#INC-1)
          ]  ;
      },
'Identified entry in @INC with double colons';
}  ;

==> b1136 <==
{
     ok do{
          grep{$_ eq$lib}
            @INC[0..(
                 $#INC-1)];
       },
'Identified entry in @INC with double colons';
}

{
     ok do{
          grep{$_ eq$lib}
            @INC[0..(
                 $#INC-1)];
       },
'Identified entry in @INC with double colons';
}


==> b1137 <==
  $out->{errors}=
          [{
   tag=>'OOPS',
   fail=>!$ENV{FAILURE_DO_PASS},
   details=>"An error occurred"
          }];

  $out->{errors}=
          [{
   tag=>'OOPS',
   fail=>!$ENV{FAILURE_DO_PASS},
   details=>"An error occurred"
          }];


==> b1138 <==
    if !(
      grep {
        File::Spec->can(
          $_) !=
          File::Spec::Unix
          ->can($_)
        } @{
        $udeps{$meth}}
      )

      if !(
      grep {
        File::Spec->can(
          $_) !=
          File::Spec::Unix
          ->can($_)
        } @{
        $udeps{$meth}}
      )

==> b1139 <==
# the first line is required to cause this
chdir$test_dir or die"Can't chdir $test_dir";
@INC=
      (File::Spec->catdir((File::Spec->updir)x 3,
                          qw(lib) ));

chdir$test_dir or die"Can't chdir $test_dir";
@INC=
      (File::Spec->catdir((File::Spec->updir)x 3,
                          qw(lib) ));

==> b114 <==
# State 1

{
    {
        if ( ref($template) ) {
            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;
        }
    }
}

# State 2

{
    {
        if ( ref($template) ) {
            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;
        }
    }
}

==> b1140 <==
  @tags{
   _unpack_tags(  $^H{$class} )
  } = ();

  @tags{
   _unpack_tags(  $^H{$class} )
  } = ();

  @tags{
   _unpack_tags(  $^H{$class} )
  } = ();

==> b1141 <==
my @schedule = (

 {name    => 'Single selectable source',
  sources => sub {
   return [ TAP::Parser->new( { source => File::Spec->catfile( 't', 'sample-tests', 'simple' ), } ),
            [ '1..5', 'ok 1', 'ok 2', 'ok 3', 'ok 4', 'ok 5', ] ];
  }, },

);

==> b1142 <==
      is_deeply(
            [sets_plan({plan=>{}})],
            [0],
"Empty plan means count of 0, nothing extra"
      );

      is_deeply(
            [sets_plan({plan=>{}})],
            [0],
"Empty plan means count of 0, nothing extra"
      );

==> b1143 <==
    {
        $crc =
          ( $crc >> 8 )
          ^ autodin_ii_table
          ->[ (
              $crc ^ $byte )
          & 0xff ];
    }

    {
        $crc =
          ( $crc >> 8 )
          ^ autodin_ii_table
          ->[ (
              $crc ^ $byte )
          & 0xff ];
    }


==> b1144 <==
  my @tests = (
    [ 1,
      {'AB' => ''} =>
        [
        [ 'AB' => '' ] ]
    ],
  );

  my @tests = (
    [ 1,
      {'AB' => ''} =>
        [
        [ 'AB' => '' ] ]
    ],
  );

==> b1145 <==
    $self->{values}[
      $#{
          $self->{values}
      }
    ];

    $self->{values}[
      $#{
          $self->{values}
      }
    ];


==> b1146 <==
    my $line_number=
      $self->{line_no}
      ->[@{$self
          ->{line_no}}-
      @{$self->{line}}-
      1];

    my $line_number=
      $self->{line_no}
      ->[@{$self
          ->{line_no}}-
      @{$self->{line}}-
      1];

==> b1147 <==
    @summary=
      @output[12..(
          $#output-1)];

    @summary=
      @output[12..(
          $#output-1)];


==> b1148 <==
        $self->{line_no}
            ->[ @{ $self
                ->{line_no} } -
            @{ $self->{line} } -
            1 ];

        $self->{line_no}
            ->[ @{ $self
                ->{line_no} } -
            @{ $self->{line} } -
            1 ];

        $self->{line_no}
            ->[ @{ $self
                ->{line_no} } -
            @{ $self->{line} } -
            1 ];


==> b1149 <==
my %results = (
T_UV =>
   {
type      => 'u',
with_size => undef,
what      => '(UV)$var',
what_size => undef
   },
);

my %results = (
T_UV =>
   {
type      => 'u',
with_size => undef,
what      => '(UV)$var',
what_size => undef
   },
);

==> b1150 <==
my %base = (
'meta-spec' =>
   {
url     => "http://search.cpan.org/perldoc?CPAN::Meta::Spec",
version => 2,
   },
);

my %base = (
'meta-spec' =>
   {
url     => "http://search.cpan.org/perldoc?CPAN::Meta::Spec",
version => 2,
   },
);

==> b1151 <==
  my %tag_cache = (
    'all' =>
      [
      map { "CORE::$_" }
        @{$TAGS{':all'}}
      ],
  );

  my %tag_cache = (
    'all' =>
      [
      map { "CORE::$_" }
        @{$TAGS{':all'}}
      ],
  );


==> b1152 <==
    my@displayable=
        @$items[$pos..(
            $pos+$limit)];

    my@displayable=
        @$items[$pos..(
            $pos+$limit)];


==> b1153 <==
 @summary = @output[
        6 .. (
               $#output - 1
        )
 ];

 @summary = @output[
        6 .. (
               $#output - 1
        )
 ];


==> b1154 <==
                  unshift @str,
                            chr
                            $I8_2_utf->[(
                                  $ucp&0x1f)
                            |0xA0];

                  unshift @str,
                            chr
                            $I8_2_utf->[(
                                  $ucp&0x1f)
                            |0xA0];

==> b1155 <==
%aa = (
uvar =>
  {
char   => 'U',
vtable => 'uvar',
desc   => 'Available for use by extensions'
  },
);

%aa = (
uvar =>
  {
char   => 'U',
vtable => 'uvar',
desc   => 'Available for use by extensions'
  },
);

==> b1156 <==
  $distros{ distro_base (
                     $short_distro)
  }{$distro} = 1 ;

  $distros{ distro_base (
                     $short_distro)
  }{$distro} = 1 ;

==> b1157 <==
 @summary = @output[
        12 .. (
                $#output - 1
        )
 ];

 @summary = @output[
        12 .. (
                $#output - 1
        )
 ];


==> b1158 <==
%language_for = (
'13' =>
   {
tokens => \%v13,
setup  => sub { shift->{iterator}->handle_unicode; },
   },
);

%language_for = (
'13' =>
   {
tokens => \%v13,
setup  => sub { shift->{iterator}->handle_unicode; },
   },
);

==> b1159 <==
my %delta = (

5.009002 =>
  {
delta_from => 5.009001,
changed    => { 'corelist' => '1', },
removed    => {}
  },

);

my %delta = (

5.009002 =>
  {
delta_from => 5.009001,
changed    => { 'corelist' => '1', },
removed    => {}
  },

);

==> b116 <==
my %SPECIALS=(
      "mail" =>
        [
            "Received:",">From",
            "Return-Path:","Cc:",
        ],
);

==> b1160 <==
{
'Safe' =>
   {
'DISTRIBUTION' => 'RGARCIA/Safe-2.35.tar.gz',
'FILES'        => q[dist/Safe],
   },
}

{
'Safe' => {
'DISTRIBUTION' => 'RGARCIA/Safe-2.35.tar.gz',
'FILES'        => q[dist/Safe],
},
}


==> b1161 <==
{
name => 'Just includes',
args =>
  {
argv     => [ qw( one two three ) ],
includes => [ qw( four five six ) ],
  },
expect => { includes => [ qw( four five six ) ], },
}

{
name   => 'Just includes',
  args => {
argv     => [ qw( one two three ) ],
includes => [ qw( four five six ) ],
  },
  expect => { includes => [ qw( four five six ) ], },
}

==> b1162 <==
        if(defined$hints{family}){
            @infos=
                    ({
                      family=>$hints{family},
                      socktype=>$hints{socktype},
                      protocol=>$hints{protocol},
                    });
        }

        if(defined$hints{family}){
            @infos=
                    ({
                      family=>$hints{family},
                      socktype=>$hints{socktype},
                      protocol=>$hints{protocol},
                    });
        }

==> b1163 <==
      @EXPORT = (
            @{ $EXPORT_TAGS{standard} },);

      @EXPORT = (
            @{ $EXPORT_TAGS{standard} },);

==> b1164 <==
 my @displayable =@$items[
        $pos .. (
                  $pos+$limit
        )
 ];

 my @displayable =@$items[
        $pos .. (
                  $pos+$limit
        )
 ];

==> b1165 <==
 $lb_table[
        $lb_enums{
         'E_Base'}
        ][
        $lb_enums{
         'E_Modifier'}
        ]
        = $lb_actions{
  'LB_NOBREAK'};

 $lb_table[
        $lb_enums{
         'E_Base'}
        ][
        $lb_enums{
         'E_Modifier'}
        ]
        = $lb_actions{
  'LB_NOBREAK'};

==> b1166 <==
my $connect =
   {
headers =>
   {
host         => "$request->{host}:$request->{port}",
'user-agent' => $agent,
   }
   };

my $connect =
   {
headers =>
   {
host         => "$request->{host}:$request->{port}",
'user-agent' => $agent,
   }
   };

==> b1167 <==
my $xx =
   {
'expr::array::lex_1const_m1' =>
   {
desc  => 'lexical $array[-1]',
setup => 'my @a = (1)',
code  => '$a[-1]',
   },
   };

my $xx =
   {
'expr::array::lex_1const_m1' =>
   {
desc  => 'lexical $array[-1]',
setup => 'my @a = (1)',
code  => '$a[-1]',
   },
   };


==> b1168 <==
my $xx =
   {
vendorarch =>
   {
s     => $vprefix,
t     => 'vendor',
d     => "$version/$arch",
style => $libstyle
   },
   };

my $xx =
   {
vendorarch =>
   {
s     => $vprefix,
t     => 'vendor',
d     => "$version/$arch",
style => $libstyle
   },
   };


==> b1169 <==
         is (
                  causes_fail (
                           {errors => [ {fail => 1} ]}
                  ),
                  1,
                  "Fatal errors cause failure"
         );

==> b117 <==
            # Same as Bug96
            # State 1
            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;

            # State 2

            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;


==> b1170 <==
         # S1
         my $hsh : shared =
                shared_clone (
                  {'foo' => [ qw/foo bar baz/ ]} );

         # S2

         my $hsh : shared =
                shared_clone (
                  {'foo' => [ qw/foo bar baz/ ]} );

==> b1171 <==
         # S1
         my $parser =
                TAP::Parser->new (
                  {source => [ split /$/, $tap ]});

         # S2
         my $parser =
                TAP::Parser->new (
                  {source => [ split /$/, $tap ]});

==> b1172 <==
# S1

ok(
         '[{"1":[5]}]' eq
                  encode_json
                  [
                  {1=>[5]}
                  ]);

# S2

ok(
         '[{"1":[5]}]' eq
                  encode_json
                  [
                  {1=>[5]}
                  ]);


==> b1173 <==
# problem caused by -wn and -bbhbi not working together

   # S1
   my $two =
        $CLASS
        ->new(
      facet_data =>
           { hubs =>
              [
            { details =>
"DO NOT SHOW"
            } ],
           } );

   # S2

   my $two =
        $CLASS
        ->new(
      facet_data =>
           { hubs =>
              [
            { details =>
"DO NOT SHOW"
            } ],
           } );

==> b1174 <==
# S1

if ( $op and $op eq 'do_search' ) {
    @{$invoices} =
      GetInvoices(
          shipmentdatefrom =>
          $shipmentdatefrom
          ? output_pref( {
                         str => $shipmentdatefrom,
                         dateformat => 'iso'
          } )
          : undef,
          publicationyear => $publicationyear,
      );
}

# S2

if ( $op and $op eq 'do_search' ) {
    @{$invoices} =
      GetInvoices(
          shipmentdatefrom =>
          $shipmentdatefrom
          ? output_pref( {
                         str => $shipmentdatefrom,
                         dateformat => 'iso'
          } )
          : undef,
          publicationyear => $publicationyear,
      );
}

==> b1175 <==
# S1

my $json_response
  = decode_json $t
  ->tx->res->content
  ->get_body_chunk;

# S2

my $json_response
  = decode_json $t
  ->tx->res->content
  ->get_body_chunk;

==> b1176 <==
                # S1
                if (
                        $enter->flags &
                        OPf_STACKED
                        and
                        not
                        null $ary
                        ->first
                        ->sibling
                        ->sibling )
                {
                        ...;
                }

                # S2
                if (
                        $enter->flags &
                        OPf_STACKED
                        and
                        not
                        null $ary
                        ->first
                        ->sibling
                        ->sibling )
                {
                        ...;
                }

==> b1178 <==
# S1
use Modern::Perl;
use CGI qw ( -utf8 );
use Koha::FrameworkPlugin;
my $input = CGI->new;
my $plugin =
  Koha::FrameworkPlugin->new( {
          name => scalar $input->param("plugin_name"),
  } );

# S2
use Modern::Perl;
use CGI qw ( -utf8 );
use Koha::FrameworkPlugin;
my $input = CGI->new;
my $plugin =
  Koha::FrameworkPlugin->new( {
          name => scalar $input->param("plugin_name"),
  } );

==> b1179 <==
        # -bom and -scp were interfering
        # S1
        $resource = { id => $package->new_from_mana(
                        $result->{data}
        )->id };

        # S2
        $resource = { id => $package->new_from_mana(
                        $result->{data}
        )->id };

        # Stable
        $resource = { id => $package->new_from_mana(
                        $result->{data}
        )->id };

==> b1180 <==
# S1
$orders
         = SearchOrders(
   { ordernumber =>
               $ordernumber
               } );

# S2
$orders
         = SearchOrders(
   { ordernumber =>
               $ordernumber
               } );


==> b1181 <==
   # S1
   $marc
            = GetISBDView(
      {
         'record' =>
                  $marc,
         'template' =>
'opac',
         'framework' =>
                  $framework,
      } );

   # S2
   $marc
            = GetISBDView(
      {
         'record' =>
                  $marc,
         'template' =>
'opac',
         'framework' =>
                  $framework,
      } );


==> b1182 <==
          #S1
          my $hold = {
                    reservedate_formatted =>
                      $h->reservedate()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->reservedate
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
                    suspend_until_formatted =>
                      $h->suspend_until()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->suspend_until
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
                    expirationdate_formatted =>
                      $h->expirationdate()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->expirationdate
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
          };

          #S2
          my $hold = {
                    reservedate_formatted =>
                      $h->reservedate()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->reservedate
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
                    suspend_until_formatted =>
                      $h->suspend_until()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->suspend_until
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
                    expirationdate_formatted =>
                      $h->expirationdate()
                    ? output_pref( {
                                        dt =>
                                          dt_from_string(
                                                  $h
                                                    ->expirationdate
                                                    ()
                                          ),
                                        dateonly => 1
                    } )
                    : q{},
          };


==> b1183 <==
# S1
is(
    ref(
                Koha::Patron::Discharge::request( { borrowernumber => $patron->{borrowernumber} } )
    ),
    'Koha::Schema::Result::Discharge',
    'Discharge request sent'
);

# S2
is(
    ref(
                Koha::Patron::Discharge::request( { borrowernumber => $patron->{borrowernumber} } )
    ),
    'Koha::Schema::Result::Discharge',
    'Discharge request sent'
);

==> b1184 <==
# S1
ok( (  Win32::GetFullPathName(
                   substr(
                       $cwd, 2
                   )
       )
    )[0],
    "$dir\\"
);

# S2
ok( (  Win32::GetFullPathName(
                   substr(
                       $cwd, 2
                   )
       )
    )[0],
    "$dir\\"
);

==> b1185 <==
          # S1
          my $visible_items = {
                    map {
                              $_
                                ->itemnumber
                                => $_
                      } $biblio->items
                      ->filter_by_visible_in_opac
                      (       { patron =>
                                          $patron
                              } )->as_list
          };

          #S2
          my $visible_items = {
                    map {
                              $_
                                ->itemnumber
                                => $_
                      } $biblio->items
                      ->filter_by_visible_in_opac
                      (       { patron =>
                                          $patron
                              } )->as_list
          };

==> b1186 <==
# S1
sub null_to_zzempty { }

sub entab {

          return
            $table->{ null_to_zzempty (
                              $row ) }
            ->{ null_to_zzempty ( $col ) };
}

# S2
sub null_to_zzemptY { }

sub entaB {

          return
            $table->{ null_to_zzemptY (
                              $row ) }
            ->{ null_to_zzemptY ( $col ) };
}

==> b1187 <==
# S1
find(
      sub {
                while(
                       defined(
                                my $line =
                                  <$fh>
                       )
                  )
                {
                          ...;
                }
      },
      @argv
);

# S2
find(
      sub {
                while(
                       defined(
                                my $line =
                                  <$fh>
                       )
                  )
                {
                          ...;
                }
      },
      @argv
);

==> b1188 <==
# S1
find(
      sub {
                while(
                       defined( my $line =
                                  <$fh>))
                {
                          ...;
                }
      },
      @argv);

# S2
find(
      sub {
                while(
                       defined( my $line =
                                  <$fh>))
                {
                          ...;
                }
      },
      @argv);

==> b1189 <==
#S1
if ($ON_EBCDIC)
{   delete @Encode::ExtModule{
        qw(euc-cn gb2312 gb12345 gbk cp936 iso-ir-165 MacChineseSimp
     euc-jp iso-2022-jp 7bit-jis shiftjis MacJapanese cp932
     euc-kr ksc5601 cp949 MacKorean
     big5	big5-hkscs cp950 MacChineseTrad
     gb18030 big5plus euc-tw)
    };
}

#S2
if ($ON_EBCDIC)
{   delete @Encode::ExtModule{
        qw(euc-cn gb2312 gb12345 gbk cp936 iso-ir-165 MacChineseSimp
     euc-jp iso-2022-jp 7bit-jis shiftjis MacJapanese cp932
     euc-kr ksc5601 cp949 MacKorean
     big5	big5-hkscs cp950 MacChineseTrad
     gb18030 big5plus euc-tw)
    };
}

==> b1190 <==
# S1
print
  "not "
  unless
  ref+(
    map{
        sub:lvalue
        {
            "a";
        }
    }1
  )[0]eq
  "CODE";

# S2
print
  "not "
  unless
  ref+(
    map{
        sub:lvalue
        {
            "a";
        }
    }1
  )[0]eq
  "CODE";


==> b1191 <==
    # S1
    $_[0]eq$_[1]
      or($_[1]=~/^([!~])(.)([\x00-\xff]*)/)
      and($1 eq '!')
      ^(eval{($_[2]."::".$_[0])=~/$2$3/;});

    # S2

    $_[0]eq$_[1]
      or($_[1]=~/^([!~])(.)([\x00-\xff]*)/)
      and($1 eq '!')
      ^(eval{($_[2]."::".$_[0])=~/$2$3/;});


==> b1192 <==
          # S1
          @EXPORT =
              ( @{$EXPORT_TAGS{standard}}, );

          # S2
          @EXPORT =
              ( @{$EXPORT_TAGS{standard}}, );

==> b1193 <==
                              # S1
                              $config->{$key}
                               =[$config->{$key}
                               ];

                              # S2
                              $config->{$key}
                               =[$config->{$key}
                               ];

==> b1194 <==
          # S1
          is(0+keys%mani,0+@files,"no duplicate files in MANIFEST")
          or diag(
                   join("\n  ","Duplicates:",grep$mani{$_}>1,
                         keys%mani)
          );

          # S2
          is(0+keys%mani,0+@files,"no duplicate files in MANIFEST")
          or
          diag(join("\n  ","Duplicates:",grep$mani{$_}>1,keys%mani));


==> b1196 <==
# S1
ok( $strX eq NFC( join( '', @strX ) ) );

# S2
ok( $strX eq NFC( join( '', @strX ) ) );

==> b1197 <==
# S1
if ( compare ( "$file.new", $file ) )

          # S2
          if ( compare ( "$file.new", $file ) )

==> b1198 <==
if ( open( SH, '<', "${outdir}config_h.SH" ) )

          if (
         open( SH, '<', "${outdir}config_h.SH" ) )

==> b1199 <==
                  if ( open( CONFIG_H_SH, '<', 'config_h.SH' ) )

                            if (
                           open( CONFIG_H_SH, '<', 'config_h.SH' ) )

==> b120 <==
            # Same as bug96
            # State 1
            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;

            # State 2
            $data = unpack(
                            $$template[2],
                            pack(
                                  $$template[1],
                                  unpack( $$template[0], $data )
                            )
            ) ;


==> b1202 <==
      $_res =
               (
            $severity_host_count{$b}
                     <=> $severity_host_count{
                  $a} );

      $_res =
               (
            $severity_host_count{$b}
                     <=> $severity_host_count{
                  $a} );

==> b1203 <==
                              if(
                                     !$found
                                    &&$word
                                    &&(
                                          ($ref_info=
                                                $references{$word}))
                                )

                                if(
                                     !$found
                                    &&$word
                                    &&(
                                          ($ref_info=
                                                $references{$word}))
                                )

==> b1205 <==
        # S1 (x was being misparsed as a function call)
        print $" x( 27 - @| ) . $. . $" x 5;

        # S2
        print $" x( 27 - @| ) . $. . $" x 5;

==> b1206 <==
# S1

if (
   $version ge
   '2.8.0' )
{  $cons->run ( {
'-sequence'
              => $aln2,
'-outseq'
              =>
              $consoutfile
      } );
}

# S2

if (
   $version ge
   '2.8.0' )
{  $cons->run ( {
'-sequence'
              => $aln2,
'-outseq'
              =>
              $consoutfile
      } );
}


==> b1207 <==
                    #OK:                kkkkkbZZZZZZZZbxbiiiiiiii;
                    print $comment x$verbose;

                    #ERR:               kkkkkbZZZZZZZZbwZZZZZZZZ;
                    print $comment x$verbose;


==> b1208 <==
    # S1

    my $home = (
          $^O =~ /mswin32/i
        ? $ENV{HOME}
        : (
            eval {
                ( getpwuid($>) )[7];
            } ## end eval
                     || $ENV{HOME}
        )
    );

    # S2

    my $home = (
          $^O =~ /mswin32/i
        ? $ENV{HOME}
        : (
            eval {
                ( getpwuid($>) )[7];
            } ## end eval
                     || $ENV{HOME}
        )
    );

==> b1209 <==
# S1
$bc[
  ord ( substr ( $P, $i, 1 ) )
] = $j--;

# S2
$bc[
  ord (
            substr ( $P, $i, 1 ) ) ]
  = $j--;

==> b1210 <==
# S1
@mo = (
        Jan, Feb, Mar, Apr,
        May, Jun, Jul, Aug,
        Sep, Oct, Nov, Dec
);

# S2
@mo = (
        Jan, Feb, Mar, Apr,
        May, Jun, Jul, Aug,
        Sep, Oct, Nov, Dec
);


==> b1211 <==
 # S1
 my$d=
   \substr(
        (state$tb=$thunderbirds[$x]),
        $x,1);

 # S2
 my$d=
   \substr(
        (state$tb=$thunderbirds[$x]),
        $x,1);


==> b1212 <==
  # S1
  my $line_count
      = scalar
      @{ [lines ()]
      };

  # S2
  my $line_count
      = scalar
      @{ [lines ()]
      };

==> b1213 <==
     # S1
     @NNVN_w1 = (
          Perl, Practical,
          Precocious
     );

     # S2
     @NNVN_w1 = (
          Perl, Practical,
          Precocious
     );

==> b1214 <==
            # S1
            eval {
                'foo'
                         =~
/$pattern/,
                         1;
            }

                   # S2
                     eval
            {
                'foo'
                         =~
/$pattern/,
                         1;
            }

==> b1215 <==
  # S1
  my $dists
      =sqrt (
    (
      $vecs**2
    )->sumover )
      +0.0001;

  # S2
  my $dists
      =sqrt (
    (
      $vecs**2
    )->sumover )
      +0.0001;

==> b1218 <==
# S1
is(
     Koha::Acquisition::Funds->search->count,
     $nb_of_funds + 1,
     'The fund should have been added'
);

# S2
is(
     Koha::Acquisition::Funds->search->count,
     $nb_of_funds + 1,
     'The fund should have been added'
);


==> b1219 <==
# S1
subtest 'check_password hook tests'=>sub{
         ok($patron->set_password({password=>'explosion',skip_validation=>1}),
                 'Patron password updated via skip validation');
};

#S2
subtest 'check_password hook tests'=>sub{
         ok($patron->set_password({password=>'explosion',skip_validation=>1}),
                 'Patron password updated via skip validation');
};

==> b1220 <==
# S1
print$msg,
 "\n",
 '-' x
 length$msg,
 "\n";

# S2
print$msg,
 "\n",
 '-' x
 length$msg,
 "\n";

==> b1221 <==
 # S1
 ok(
  defined(
                $pdf->{'ROOT'}->{'Resources'}->{'Font'}->{$fk}
  ));

 # S2
 ok(defined($pdf->{'ROOT'}->{'Resources'}->{'Font'}->{$fk}
 ));

==> b1224 <==
  # S1
  return ( $self->_testStrand ( $other, $so )
             and not( (
                       $self->start () > $other->end ()
                    or $self->end () < $other->start ()
             ) )
  );

  #S2
  return ( $self->_testStrand ( $other, $so )
             and not( (
                       $self->start () > $other->end ()
                    or $self->end () < $other->start ()
             ) )
  );

==> b1227 <==
# S1
foreach$n(qw( msm ali ))
{
    foreach$e(qw(
              uc16
    ));
}

# S2
foreach$n(qw( msm ali ))
{
    foreach$e(qw(
              uc16
    ));
}

==> b1228 <==
# S1
$obj= {
    foo => sub { "bar" ; }
} ;

# S2
$obj= {
    foo => sub { "bar" ; }
} ;

==> b1229 <==
              # S1
              $n
                     += (
                           $b
                           = sysread( $data,    ${*$data},
                                      $blksize, $l )
                     );

              # S2
              $n
                     += (
                           $b
                           = sysread( $data,    ${*$data},
                                      $blksize, $l )
                     );

==> b1230 <==
    # S1
    join(
        '',
        map {
            $_ eq "\e" ? '\M-'
                  : ord($_) < 32
                  ? '\C-'
                  . lc(
                chr( ord($_) + 64 ) )
                  : $_
        } ( split( '', $_[0] ) ) );

    # S2
    join(
        '',
        map {
            $_ eq "\e" ? '\M-'
                  : ord($_) < 32
                  ? '\C-'
                  . lc(
                chr( ord($_) + 64 ) )
                  : $_
        } ( split( '', $_[0] ) ) );

==> b1231 <==
# S1
@data =
         (
          [
           "1st", "2nd", "3rd", "4th",
           "5th", "6th", "7th", "8th",
           "9th"
          ],
          [
           1, 2, 5, 6, 3, 1.5, 1, 3, 4
          ],
         );

# S2
@data =
         (
          [
           "1st", "2nd", "3rd", "4th",
           "5th", "6th", "7th", "8th",
           "9th"
          ],
          [
           1, 2, 5, 6, 3, 1.5, 1, 3, 4
          ],
         );

==> b1232 <==
        # S1
        $method.="AdminMode"
          if( (defined($context->{args}->{admin_mode}))
              &&($context->{args}->{admin_mode}eq"yes")
          );

        # S2
        $method.="AdminMode"
          if( (defined($context->{args}->{admin_mode}))
              &&($context->{args}->{admin_mode}eq"yes")
          );

==> b1234 <==
# S1
is(
    Pack
              ->
              $mname
              (
        "a", "b",
        "c" ),
"method,a,b,c"
);

# S2
is(
    Pack
              ->
              $mname
              (
        "a", "b",
        "c" ),
"method,a,b,c"
);

==> b1235 <==
  # S1
  my $oldage
          = (
   sort { $a <=> $b }
   map { -M } @files )[-1];
  my $depage
          = (
   sort { $a <=> $b }
   map { -M } @deps )[0];

  # S2
  my $oldage
          = (
   sort { $a <=> $b }
   map { -M } @files )[-1];
  my $depage
          = (
   sort { $a <=> $b }
   map { -M } @deps )[0];

==> b1236 <==
# Added level test when applying kpit
# S1
        delete $ENV{$_}
                for
                map {$_, uc ($_)}
                qw/http_proxy https_proxy all_proxy/;

        # S2
        delete $ENV{$_}
                for
                map {$_, uc ($_)}
                qw/http_proxy https_proxy all_proxy/;

        # S3
        delete $ENV{$_}
                for
                map {$_, uc ($_)}
                qw/http_proxy https_proxy all_proxy/;


==> b1237 <==
 # S1
 my $h
         = {
  map {$_ => uc $_}
          'a' .. 'z' };

 # S2
 my $h
         = {
  map {$_ => uc $_}
          'a' .. 'z' };

==> b1238 <==
  # S1
  local
          $Other::{ ${ \
            "f4" } } =
          sub { "h1" };

  # S2
  local
          $Other::{ ${ \
            "f4" } } =
          sub { "h1" };

==> b1239 <==
# S1
( sockaddr_in( getsockname ( $_[0]->[_SOCKET] ) )
)[0];

# S2
( sockaddr_in( getsockname ( $_[0]->[_SOCKET] ) )
)[0];

==> b1240 <==
     # S1
     printf(
"Inode Last Change at: %s\n",
          scalar
             localtime($ctime) );

     # S2
     printf(
"Inode Last Change at: %s\n",
          scalar
             localtime($ctime) );

==> b1241 <==
    # created from b901
    # Started blinking with new -lp logic
    # S1
    my @tagged_texts =
             walk_html(
                      $tree,
                      sub { [ 'MAYBE', $_[ 0 ] ] },
                      \&promote_if_h1tag
             );

    # S2
    my @tagged_texts = walk_html(
        $tree,
        sub
        {
            [ 'MAYBE', $_[ 0 ] ]
        },
        \&promote_if_h1tag
    );

==> b1243 <==
# S1
use
  ExtUtils::MakeMaker;
WriteMakefile(
 NAME =>
"PDL::Opt::Simplex",
 PM => {
  map {
   (
    $_ =>
'$(INST_LIBDIR)/'
      . $_ )
  } <*.pm>
 }
);

# S2
use
  ExtUtils::MakeMaker;
WriteMakefile(
 NAME =>
"PDL::Opt::Simplex",
 PM => {
  map {
   (
    $_ =>
'$(INST_LIBDIR)/'
      . $_ )
  } <*.pm>
 }
);

==> b1244 <==
     # S1
     @NVNN_w2 = (
          Lampoons,  Launders,
          Leapfrogs, Leaps,
          Learns,    Legitimizes,
          Levels,    Levitates,
          Liberates, Lightens,
          Likes,     Liquidates,
          Loathes,   Loosens,
          Loves,     Lubricates,
     );

     @NNVN_w3 = (
          Unclutters, Unfetters,
          Unifies,    Unites,
          Unseats,    Upgrades,
          Upstages,   Uses,
          Usurps,
     );

     # S2
     @NVNN_w2 = (
          Lampoons,  Launders,
          Leapfrogs, Leaps,
          Learns,    Legitimizes,
          Levels,    Levitates,
          Liberates, Lightens,
          Likes,     Liquidates,
          Loathes,   Loosens,
          Loves,     Lubricates,
     );

     @NNVN_w3 = (
          Unclutters, Unfetters,
          Unifies,    Unites,
          Unseats,    Upgrades,
          Upstages,   Uses,
          Usurps,
     );

==> b1250 <==
  # S1
  @dependents=
  (
           split(
             $delim,$dependent{$ctr} )
  );

  # S2
  @dependents=
  (
           split(
             $delim,$dependent{$ctr} )
  );

==> b1251 <==
              # S1
              if (
                     !(     $line =~
                            /\\(nonumber|(no)?tag)/ ) )

                # S2
                if (
                     !(     $line =~
                            /\\(nonumber|(no)?tag)/ ) )

==> b1252 <==
# S1
@pack=([
"ufunc.pd",
        Ufunc,
        PDL::Ufunc
    ]);

# S2
@pack=([
"ufunc.pd",
        Ufunc,
        PDL::Ufunc
    ]);

==> b1255 <==
printf
  (
"%-20s %-50s\n",
    "-"
      x 20,
    "-"
      x 50
  );

printf
  (
"%-20s %-50s\n",
    "-"
      x 20,
    "-"
      x 50
  );


==> b1256 <==
        # S1
        &$out( assemble_insn(
            $insn, $arg ) );

        # S2
        &$out(
            assemble_insn(
                $insn, $arg ) );

==> b1257 <==
    # S1
    my $hour_angle
      = 2 * PI
      * ( $hour / 12 + $min / ( 12 * 60 ) )
      - PI / 2;

    # S2
    my $hour_angle
      = 2 * PI
      * ( $hour / 12 + $min / ( 12 * 60 ) )
      - PI / 2;

==> b1259 <==
    # S1
    $menubar->Menubutton(
        -tearoff=>0,
        -text=>'File',
        -menuitems=>
                 [
            [Button=>'Save',-command=>\&save_bookmarks],
            [Button=>'Quit',-command=>\&exit_program],
                 ]
    )->pack(-side=>'left');

    # S2
    $menubar->Menubutton(
        -tearoff=>0,
        -text=>'File',
        -menuitems=>
                 [
            [Button=>'Save',-command=>\&save_bookmarks],
            [Button=>'Quit',-command=>\&exit_program],
                 ]
    )->pack(-side=>'left');

==> b1260 <==
        # S1
        my @cmd =

                 ( $::cfg_path_diff, split ( / /, $::cfg_args_diff ), $match1,
                $match2 ) ;

        # S2
        my @cmd =

                 ( $::cfg_path_diff, split ( / /, $::cfg_args_diff ), $match1,
                $match2 ) ;

==> b1262 <==
            # S1
            @theme_args =
              get_themes(
                \%opt, (
                    $2 ? $2 :
                      (
                        shift(
                            @theme_args)
                          ||
                          shift(@ARGV)
                      ) ) );

            # S2
            @theme_args =
              get_themes(
                \%opt, (
                    $2 ? $2 :
                      (
                        shift(
                            @theme_args)
                          ||
                          shift(@ARGV)
                      ) ) );

==> b1264 <==
#S1
function(
          'objectclass'=>[
                         'top','person',
                         'organizationalPerson',
                         'inetOrgperson'
          ],
);

# S2
function(
          'objectclass'=>[
                         'top','person',
                         'organizationalPerson',
                         'inetOrgperson'
          ],
);

# S3
function(
          'objectclass'=>[
                         'top','person',
                         'organizationalPerson',
                         'inetOrgperson'
          ],
);

==> b1266 <==
        $self->{SUMMARY} =
          [
           {
              'descr' => 'Total number of users using the site',
              'value' => commify ($total_users)
           }
          ];

        $self->{SUMMARY} =
          [
           {
              'descr' => 'Total number of users using the site',
              'value' => commify ($total_users)
           }
          ];

==> b1267 <==
    # S1
    foreach (
        grep
        ( $self->{_unique_nodes}->{$_}
              > 1,
            keys
              %{ $self->{_unique_nodes} }
        )
      )

      # S2
      foreach (
        grep
        ( $self->{_unique_nodes}->{$_}
              > 1,
            keys
              %{ $self->{_unique_nodes} }
        )
      )

==> b1268 <==
$|||=sub
{   ($_[$[<$]],$_[$[])
};

$|||=sub
{   ($_[$[<$]],$_[$[])
};

==> b1269 <==
use overload
     "=="=>\&_equals,
     "!="=>
     sub{not _equals(@_)},
     q{""}=>
     sub{($_[0]->{_type})};

use overload
     "=="=>\&_equals,
     "!="=>
     sub{not _equals(@_)},
     q{""}=>
     sub{($_[0]->{_type})};


==> b1270 <==
          $this->{SymAutoCor} =
            ( PDL->zeroes(
                              $n *
                                2 -
                                1
          )->float );

          $this->{SymAutoCor} =
            ( PDL->zeroes(
                              $n *
                                2 -
                                1
          )->float );


==> b1271 <==
          exit (
                    $opts{"-exitval"}
          ) ;

          exit (
                    $opts{"-exitval"}
          ) ;

==> b1272 <==
 $this->{Normals} = (
      PDL->zeroes(
       3,
       ( map { $_ - 1 } @{ $this->{XYDims} } ),
       @{ $this->{OverDims} }
      )->double
 )->dummy( 3, $this->{XYDims}[1] );

 $this->{Normals} = (
      PDL->zeroes(
       3,
       ( map { $_ - 1 } @{ $this->{XYDims} } ),
       @{ $this->{OverDims} }
      )->double
 )->dummy( 3, $this->{XYDims}[1] );


==> b1273 <==
                     if (
                            ( $n =
                                   index( $trial,
                                          $frag ) ) >=
                            $[
                     );

                     if (
                            ( $n =
                                   index( $trial,
                                          $frag ) ) >=
                            $[
                     );

==> b1274 <==
       # S1
       $$d{"month_abb"} =
       [
          [
             "Jan", "Feb", "Mar", "Apr", "Maj", "Jun",
             "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
          ]
       ];

       # S2
       $$d{"month_abb"} =
       [
          [
             "Jan", "Feb", "Mar", "Apr", "Maj", "Jun",
             "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
          ]
       ];

       # S3
       $$d{"month_abb"} =
       [
          [
             "Jan", "Feb", "Mar", "Apr", "Maj", "Jun",
             "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"
          ]
       ];


==> b1275 <==
    $$d{"month_abb"} = [
           [
               "sty.", "lut.", "mar.", "kwi.", "maj", "cze.", "lip.", "sie.", "wrz.", "paz.", "lis.", "gru."
           ], [
               "sty.", "lut.", "mar.", "kwi.", "maj", "cze.", "lip.", "sie.", "wrz.", "pa.", "lis.", "gru."
           ]
       ];

    $$d{"month_abb"} = [
           [
               "sty.", "lut.", "mar.", "kwi.", "maj", "cze.", "lip.", "sie.", "wrz.", "paz.", "lis.", "gru."
           ], [
               "sty.", "lut.", "mar.", "kwi.", "maj", "cze.", "lip.", "sie.", "wrz.", "pa.", "lis.", "gru."
           ]
       ];

==> b1277 <==
          # S1
          match_on_type @_ => Null => sub { [] },
                  ArrayRef =>
                  sub { [ @{ rev ( tail ($_) ) }, head ($_) ] } ;

          # S2
          match_on_type @_ => Null => sub { [] },
                  ArrayRef => sub
          {
                    [ @{ rev ( tail ($_) ) }, head ($_) ]
          } ;

          # S3
          match_on_type @_ => Null => sub { [] },
                  ArrayRef =>
                  sub { [ @{ rev ( tail ($_) ) }, head ($_) ] } ;


==> b1278 <==
    # S1
    match_on_type @_  => Null => sub { [] },
             ArrayRef => sub
    {   [ @{ rev( tail($_) ) }, head($_) ]
    };

    # S2
    match_on_type @_  => Null => sub { [] },
             ArrayRef => sub
    {   [ @{ rev( tail($_) ) }, head($_) ]
    };

==> b1280 <==
    # S1
    for my $method qw(GetBook Wishlist AddBook RemoveBook
      PurchaseBooks)
      {
        eval "sub $method";
        *$method = sub {
            my $self = shift->new;
            die SOAP::Fault->faultcode('Server.RequestError')
              ->faultstring('Could not get object')
              unless $self;

            my $smethod = "SUPER::$method";
            my $res     = $self->$smethod(@_);
            die SOAP::Fault->faultcode('Server.ExecError')
              ->faultstring("Execution error: $res")
              unless ref($res);

            $res;
        };
      }

    # S2
    for my $method qw(GetBook Wishlist AddBook RemoveBook
      PurchaseBooks)
      {
        eval "sub $method";
        *$method = sub {
            my $self = shift->new;
            die SOAP::Fault->faultcode('Server.RequestError')
              ->faultstring('Could not get object')
              unless $self;

            my $smethod = "SUPER::$method";
            my $res     = $self->$smethod(@_);
            die SOAP::Fault->faultcode('Server.ExecError')
              ->faultstring("Execution error: $res")
              unless ref($res);

            $res;
        };
      }

==> b1283 <==
       $_=join(
              '',$_,
              (      ($MAX_SPLIT_DEPTH<=
                              $section_commands{$outermost_level})?
                       "\n<HR>\n":''
              ),
              "\\$outermost_level",
              "*",
              "$O$X$C$O$Y$C\\infopagename$O$Y$C$O$X$C\n",

              " \\textohtmlinfopage" );

       $_=join(
              '',$_,
              (      ($MAX_SPLIT_DEPTH<=
                              $section_commands{$outermost_level})?
                       "\n<HR>\n":''
              ),
              "\\$outermost_level",
              "*",
              "$O$X$C$O$Y$C\\infopagename$O$Y$C$O$X$C\n",

              " \\textohtmlinfopage" );

==> b1284 <==
                     # S1
                     if (   ($before)
                            && ( !($before=~/$begin_env_rx|$begin_cmd_rx/ ) )
                     );

                     # S2
                     if (   ($before)
                            && ( !($before=~/$begin_env_rx|$begin_cmd_rx/ ) )
                     );


==> b1285 <==
foreach $func (
        @{$Win32API::Registry::EXPORT_TAGS{FuncA}
        },
        @{$Win32API::Registry::EXPORT_TAGS{FuncW}
        }
);

foreach $func (
        @{$Win32API::Registry::EXPORT_TAGS{FuncA}
        },
        @{$Win32API::Registry::EXPORT_TAGS{FuncW}
        }
);


==> b1287 <==
    $" < 2 ?
            $_[ $/ ][ $. ] |= 1 << $" :
            (
        $_[ $@[ -1 ][ 1 ] ][ $@[ -1 ][ 0 ] ]
                |= 1 << $" - 2 );

    $" < 2 ?
            $_[ $/ ][ $. ] |= 1 << $" :
            (
        $_[ $@[ -1 ][ 1 ] ][ $@[ -1 ][ 0 ] ]
                |= 1 << $" - 2 );


==> b1289 <==
my $sim4
        = new Bio::Tools::Sim4::Results (
                            -file => Bio::Root::IO->catfile ( "t", "sim4.rev" ),
                            -estisfirst => 0
        );

my $sim4
        = new Bio::Tools::Sim4::Results (
                            -file => Bio::Root::IO->catfile ( "t", "sim4.rev" ),
                            -estisfirst => 0
        );


==> b1295 <==
        $after=join(
                    "","\\begin",$opt,"\{verbatim_code\}",
                    $verbatim_mark,$env,
                    $global{'verbatim_counter'},"#",
                    "\\end\{verbatim_code\}",$after
        );

        $after=join(
                    "","\\begin",$opt,"\{verbatim_code\}",
                    $verbatim_mark,$env,
                    $global{'verbatim_counter'},"#",
                    "\\end\{verbatim_code\}",$after
        );


==> b1297 <==
# S1
my %MyTokens =
  (
   '{' => $Text::TeX::Tokens{'{'},

  # Just pretend they actually ARE new paragraph markers!
   '\maketitle' => { 'class' => 'Text::TeX::Paragraph' },
  );

# S2
my %MyTokens =
  (
   '{' => $Text::TeX::Tokens{'{'},

  # Just pretend they actually ARE new paragraph markers!
   '\maketitle' => { 'class' => 'Text::TeX::Paragraph' },
  );

==> b1298 <==
# S1
my $file = $menubar->Menubutton(
     qw/-text File -underline 0 -menuitems/ =>
       [
          [  Cascade    => '~View',
             -menuitems =>
             [
                [  Button => '~widget', -command => [ \&view_widget_code, __FILE__ ]
                ],
                [ Button => '~WidgetDemo', -command => [ \&view_widget_code, $wd ] ],
             ],    # end cascade menuitems
          ],    # end view cascade
          [ Separator => '' ],
          [ Button    => '~Quit', -command => [ \&exit ] ],
       ]
)->grid(qw/-sticky w/);

# S2
my $file = $menubar->Menubutton(
     qw/-text File -underline 0 -menuitems/ =>
       [
          [  Cascade    => '~View',
             -menuitems =>
             [  [ Button => '~widget',     -command => [ \&view_widget_code, __FILE__ ] ],
                [ Button => '~WidgetDemo', -command => [ \&view_widget_code, $wd ] ],
             ],    # end cascade menuitems
          ],    # end view cascade
          [ Separator => '' ],
          [ Button    => '~Quit', -command => [ \&exit ] ],
       ]
)->grid(qw/-sticky w/);

==> b1299 <==
                                        # S1
                                        $cod_offset=
                                                  $flds[6]-
                                                  (
                                                ($predobj->start(
                                                                  )
                                                                  -
                                                                  1
                                                )% 3);

                                        # S2
                                        $cod_offset=
                                                  $flds[6]-
                                                  (
                                                ($predobj->start(
                                                                  )
                                                                  -
                                                                  1
                                                )% 3);

==> b1300 <==
$obj = {
   foo => [
      {a => "b"},
      0, 1, 2
   ]
};

$obj = {
   foo => [
      {a => "b"},
      0, 1, 2
   ]
};

==> b1301 <==
subtest '->save' => sub {
    plan tests => 1;
    my $layout
    =C4::Patroncards::Layout->new (layout_name => "new patron card",
                                   layout_id   => '',                # The interface send an empty string
                                   layout_xml  => 'some_xml'
    );
};

subtest '->save' => sub {
    plan tests => 1;
    my $layout
    =C4::Patroncards::Layout->new (layout_name => "new patron card",
                                   layout_id   => '',                # The interface send an empty string
                                   layout_xml  => 'some_xml'
    );
};

==> b1302 <==
use vars (
 q!$Start_Dir!
 ,   # The top directory find was called with
 q!%Future!, # topdirs find will handle later
);

use vars (
 q!$Start_Dir!
 ,   # The top directory find was called with
 q!%Future!, # topdirs find will handle later
);

==> b1303 <==
if ((
      $response = $browser->request($curreq)
)->is_error());

if ((
      $response = $browser->request($curreq)
)->is_error());


==> b1304 <==
          # S1
          (
                    $hisaddr=
                            recv(SOCKET,
                              $histime='',4,0)
          );

          # S2
          (
                    $hisaddr=
                            recv(SOCKET,
                              $histime='',4,0)
          );

==> b1305 <==
my %Map =(
  File::Spec->catfile(
    $Dir,"linktest_with_dir.tar"
        ) =>
        [
    [   0, qr/SECURE EXTRACT MODE/],
    [ 1, qr/^$/ ]
        ],
);

my %Map =(
  File::Spec->catfile(
    $Dir,"linktest_with_dir.tar"
        ) =>
        [
    [   0, qr/SECURE EXTRACT MODE/],
    [ 1, qr/^$/ ]
        ],
);

==> b1306 <==
$oreo =
  cookie(
        -NAME    => 'filling',
        -VALUE   => "vanilla crme",
        -EXPIRES => '+3M'
        ,   # M for month, m for minute
        -DOMAIN => '.perl.com'
  );

$oreo =
  cookie(
        -NAME    => 'filling',
        -VALUE   => "vanilla crme",
        -EXPIRES => '+3M'
        ,   # M for month, m for minute
        -DOMAIN => '.perl.com'
  );


==> b1307 <==
if ()
{   }

else { } #

if ()
{   }

else { } #


==> b131 <==
        unless (
                open( SCORE,
                        "+>>$Score_File" )
          )

==> b1310 <==
isnt(
      exception {
          $meta =
            Moose::Meta::Class->create_anon_class(
                       superclasses => ['t::bugs::Bar',], # any old class will work
                       roles        => ['Role::BreakOnLoad',], )
      },
      undef,
      'Class dies when attempting composition'
);

isnt(
      exception {
          $meta =
            Moose::Meta::Class->create_anon_class(
                       superclasses => ['t::bugs::Bar',], # any old class will work
                       roles        => ['Role::BreakOnLoad',], )
      },
      undef,
      'Class dies when attempting composition'
);


==> b1311 <==
# S1
WriteMakefile(
          'NAME'         => 'C4::Search',
          'VERSION_FROM' => 'Search.pm',    # finds $VERSION
          'PREREQ_PM'    => {},    # e.g., Module::Name => 1.1
          (
             $] >= 5.005
             ?  ## Add these new keywords supported since 5.005
             (
                ABSTRACT_FROM =>
                'Search.pm',    # retrieve abstract from module
                AUTHOR => 'Koha Dev Team <info@koha.org>'
             )
             : ()
          ),
);

# S2
WriteMakefile(
          'NAME'         => 'C4::Search',
          'VERSION_FROM' => 'Search.pm',    # finds $VERSION
          'PREREQ_PM'    => {},    # e.g., Module::Name => 1.1
          (
             $] >= 5.005
             ?  ## Add these new keywords supported since 5.005
             (
                ABSTRACT_FROM =>
                'Search.pm',    # retrieve abstract from module
                AUTHOR => 'Koha Dev Team <info@koha.org>'
             )
             : ()
          ),
);

==> b1314 <==
# S1
WriteMakefile(
     'NAME'         => 'Gimp::Net',
     'VERSION_FROM' => '../Gimp.pm',

#'INC'	=> "$INC1 $CPPFLAGS $pdl_inc $cfg{GLIB_CFLAGS} $CFLAGS",
     'INC'      => "$INC1 $CPPFLAGS $pdl_inc $CFLAGS",
     'DEFINE'   => "$DEFINE1 $DEFS",
     'TYPEMAPS' =>
           [ "$topdir/typemap", @pdl_typemaps ],

#dynamic_lib	=> { OTHERLDFLAGS => "$LDFLAGS $LIBS $cfg{GLIB_LIBS}" },
     dynamic_lib =>
           { OTHERLDFLAGS => "$LDFLAGS $LIBS" },
     'PM' => {
               'Net.pm' => '$(INST_LIBDIR)/Net.pm',
     },
);

# S2
WriteMakefile(
     'NAME'         => 'Gimp::Net',
     'VERSION_FROM' => '../Gimp.pm',

#'INC'	=> "$INC1 $CPPFLAGS $pdl_inc $cfg{GLIB_CFLAGS} $CFLAGS",
     'INC'      => "$INC1 $CPPFLAGS $pdl_inc $CFLAGS",
     'DEFINE'   => "$DEFINE1 $DEFS",
     'TYPEMAPS' =>
           [ "$topdir/typemap", @pdl_typemaps ],

#dynamic_lib	=> { OTHERLDFLAGS => "$LDFLAGS $LIBS $cfg{GLIB_LIBS}" },
     dynamic_lib =>
           { OTHERLDFLAGS => "$LDFLAGS $LIBS" },
     'PM' => {
               'Net.pm' => '$(INST_LIBDIR)/Net.pm',
     },
);

==> b1315 <==
# S1
our %EXPORT_TAGS
        = (
 'all' => [
  qw(

          ) ]
        );

# S2
our %EXPORT_TAGS
        = (
 'all' => [
  qw(

          ) ]
        );


==> b1316 <==
# S1
$garage->add_path(
        qw( move_car move_LPs move_sofa
                 hoover_floor wash_floor ));

# S2
$garage->add_path(
        qw( move_car move_LPs move_sofa
                 hoover_floor wash_floor ));

==> b1317 <==
# S1
my %config = (
    checkincludedtext =>
      0,
    includedcutoff =>
      40,
    includedratio =>
      0.6,
    quotere => '^[>:]',
    antiquotere =>
      '^[<]'
    , # so as not to reject dict(1) output
);

# S2
my %config = (
    checkincludedtext =>
      0,
    includedcutoff =>
      40,
    includedratio =>
      0.6,
    quotere => '^[>:]',
    antiquotere =>
      '^[<]'
    , # so as not to reject dict(1) output
);

==> b1318 <==
        my $h =
          $integerValue->copy()->bmod(
                                      '16'
          )->bstr();

        my $h =
          $integerValue->copy()->bmod(
                                      '16'
          )->bstr();

==> b1319 <==
# S1
my @tests = (
          {
            expects => [
                         sort
                                qw/ Class::Moose::RoleList1 Class::Moose::RoleList2 /
            ],
          },
);

# S2
my @tests = (
          {
            expects => [
                         sort
                                qw/ Class::Moose::RoleList1 Class::Moose::RoleList2 /
            ],
          },
);

==> b1321 <==
my $parser =
  Pod::Markdown->new(

     perldoc_fragment_format =>
     'pod_simple_html',    # CodeRef ( $self, $text )
     markdown_fragment_format =>
     'pod_simple_html',    # CodeRef ( $self, $text )
     include_meta_tags => 0,
  );

my $parser =
  Pod::Markdown->new(

     perldoc_fragment_format =>
     'pod_simple_html',    # CodeRef ( $self, $text )
     markdown_fragment_format =>
     'pod_simple_html',    # CodeRef ( $self, $text )
     include_meta_tags => 0,
  );

==> b1322 <==
    my$result
      =$self->bus()->connection_settermchar(
        $self->connection_handle(),$termchar
      );

    my$result
      =$self->bus()->connection_settermchar(
        $self->connection_handle(),$termchar
      );

==> b1324 <==
    if (
        blessed(
            $element->statement )
        and
        $element->statement
        ->isa(
'PPI::Statement::Variable'
        )
        and
        $element->statement
        ->type eq 'our'
        and any {
            $_->symbol eq '@ISA'
        } $element->statement
        ->symbols
    );

    if (
        blessed(
            $element->statement )
        and
        $element->statement
        ->isa(
'PPI::Statement::Variable'
        )
        and
        $element->statement
        ->type eq 'our'
        and any {
            $_->symbol eq '@ISA'
        } $element->statement
        ->symbols
    );

==> b1325 <==
WriteMakefile(
   PREREQ_PM    => {
      'Tk'            =>'800.025',
      'Tk::DiffText'  => 0,
      'Perl::Tidy'    => 0
      , # comes in the perltidy application
      'Log::Log4perl' => '1.0',
      'version'       => 0
      , # used to detect old Tk's and use different widgets where required
   },
);

WriteMakefile(
   PREREQ_PM    => {
      'Tk'            =>'800.025',
      'Tk::DiffText'  => 0,
      'Perl::Tidy'    => 0
      , # comes in the perltidy application
      'Log::Log4perl' => '1.0',
      'version'       => 0
      , # used to detect old Tk's and use different widgets where required
   },
);

==> b1327 <==
 @where=
   $self->_where()
   ->where_clause('Fey::FakeDBI',
                  'no WHERE')
   if$self->_has_where();

 @where=
   $self->_where()
   ->where_clause('Fey::FakeDBI',
                  'no WHERE')
   if$self->_has_where();

==> b1328 <==
    my $exchange
      = $self->_channel()->exchange(
                                    name => $self->_fq_name('order'),
      );

    my $exchange
      = $self->_channel()->exchange(
                                    name => $self->_fq_name('order'),
      );

==> b1330 <==
  print $tbl->render_row(
    [    #
      "$STATUS->{$status}->[2] $STATUS->{$status}->[0] $RESET",
      "$STATUS->{$status}->[2]  @{[ $total->{data}->{$status} // 0 ]}  $RESET",
    ]
  );

  print $tbl->render_row(
    [    #
      "$STATUS->{$status}->[2] $STATUS->{$status}->[0] $RESET",
      "$STATUS->{$status}->[2]  @{[ $total->{data}->{$status} // 0 ]}  $RESET",
    ]
  );

==> b1331 <==
# S1
WriteMakefile PREREQ_PM =>
  {  # e.g., Module::Name => 1.1
    'ExtUtils::MakeMaker' =>
      5.45,
    'LWP::UserAgent' => 0,
  },
  ;

# S2
WriteMakefile PREREQ_PM =>
  {  # e.g., Module::Name => 1.1
    'ExtUtils::MakeMaker' =>
      5.45,
    'LWP::UserAgent' => 0,
  },
  ;


==> b1332 <==
      # S1
      $b->configure ( -text => $dayArray[$col], # disable the button
                      -state => 'disabled' );

      # S2
      $b->configure ( -text => $dayArray[$col], # disable the button
                      -state => 'disabled' );

==> b1333 <==
        # S1
        $_[
          HEAP

          ]->{postback_tests}->{$test_number} =

          "ok $test_number\n";

        # S2
        $_[
          HEAP

          ]->{postback_tests}->{$test_number} =

          "ok $test_number\n";

==> b1334 <==
# S1
my $pcc_tt = Params::CheckCompiler::validation_for(
params =>
       [
{ type => Int },
{ type => ArrayRef },
{ type => InstanceOf ['DateTime'], optional => 1 },
       ],
);

# S2
my $pcc_tt = Params::CheckCompiler::validation_for(
params =>
       [
{ type => Int },
{ type => ArrayRef },
{ type => InstanceOf ['DateTime'], optional => 1 },
       ],
);

==> b1336 <==
    # S1
    my $expect =
            [
                {
                    type => 'preformatted',
                    text => "preformatted line\n",
                }
            ];

    # S2
    my $expect =
            [
                {
                    type => 'preformatted',
                    text => "preformatted line\n",
                }
            ];

==> b1337 <==
# S1: 'new' was given type 'i' here
        print JSON::PP->
          new->indent
          ->space_after
          ->canonical
          ->convert_blessed
          ->encode(
              $self->{abbrev}
            ? $schema
              ->abbreviated
            : $schema );

# S2: 'new' was given type 'w' here, but type 'i' is better
        print JSON::PP->
          new->indent
          ->space_after
          ->canonical
          ->convert_blessed
          ->encode(
              $self->{abbrev}
            ? $schema
              ->abbreviated
            : $schema );

==> b1338 <==
      # S1:
      (
         sockaddr_in ( getsockname( $_[0]->[_SOCKET] ) )
      )[0];

      # S2:
      (
         sockaddr_in ( getsockname( $_[0]->[_SOCKET] ) )
      )[0];

==> b1339 <==
   # S1
   $LANGUAGE{'groff'}={
        'filename'=>'\\.groff$',
        'regex'=>'',
        'patterns'=>[{'name'=>'comment','regex'=>'\\\\".*?$','style'=>'comment','childregex'=>[]}]
   };

   # S2
   $LANGUAGE{'groff'}={
        'filename'=>'\\.groff$',
        'regex'=>'',
        'patterns'=>[{'name'=>'comment','regex'=>'\\\\".*?$','style'=>'comment','childregex'=>[]}]
   };

==> b1340 <==
# S1
print to_json({success => $success ? 1 : 0});

# S2
print to_json({success => $success ? 1 : 0});

==> b1345 <==
          # S1
          $insert = [
                      map { [ _subnet_as_v6( $_->[ 0 ] ), $_->[ 1 ] ] }
                      @{$insert} ];

          # S2
          $insert = [
                      map { [ _subnet_as_v6( $_->[ 0 ] ), $_->[ 1 ] ] }
                      @{$insert} ];

==> b1346 <==
        return (
            $s + $t - $a / 3,
            -0.5 * ( $s + $t ) +
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 ),
            -0.5 * ( $s + $t ) -
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 )
        );

        return (
            $s + $t - $a / 3,
            -0.5 * ( $s + $t ) +
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 ),
            -0.5 * ( $s + $t ) -
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 )
        );

        return (
            $s + $t - $a / 3,
            -0.5 * ( $s + $t ) +
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 ),
            -0.5 * ( $s + $t ) -
                  sqrt(-1) * sqrt(3) / 2 * ( $s - $t ) -
                  ( $a / 3 )
        );

==> b1348 <==
                           # S1
                           $try =
                               $costs[ $j - $i ][$k]
                             + $costs[ $k + 1 ][$j]
                             + $row1 *
                             $col1 *
                             $col2 ;

                           # S2
                           $try =
                               $costs[ $j - $i ][$k]
                             + $costs[ $k + 1 ][$j]
                             + $row1 *
                             $col1 *
                             $col2 ;


==> b1349 <==
    # S1
    my($database,$primary_id,
       $optional_id,$comment)
           =$self
           ->_rearrange([qw(DATABASE
                         PRIMARY_ID
                         OPTIONAL_ID
                         COMMENT
                        )],
                        @args
           );

    # S2
    my($database,$primary_id,
       $optional_id,$comment)
           =$self
           ->_rearrange([qw(DATABASE
                         PRIMARY_ID
                         OPTIONAL_ID
                         COMMENT
                        )],
                        @args
           );


==> b1354 <==
# S1
while (my ( $sid, $u, $lasttime )=
         split( /:/, <S> ) )

  # S2
  while (
         my ( $sid, $u, $lasttime )
         =split( /:/, <S> ) )


==> b1355 <==
# S1
my $data =
         [ { value => "Tom" }, { value => 33 }, { value => "Sales" }, ];

# S2
my $data =
         [ { value => "Tom" }, { value => 33 }, { value => "Sales" }, ];


==> b1356 <==
# S1
%phonebook
         = (
   "Bob"  => "247305",
   "Phil" => "205832",
   "Sara" => "226010"
         );

# S2
%phonebook
         = (
   "Bob"  => "247305",
   "Phil" => "205832",
   "Sara" => "226010"
         );


==> b1357 <==
# S1
my ( $m, $i, $j )
  =( length $P, 0,
     -1 );

# S2
my ( $m, $i, $j )
  =( length $P, 0,
     -1 );

==> b1371 <==
# S1
my (
$xpos,
$ypos,
$font_size
  )
  =(
     100,
     700,
     12
  );

# S2
my (
$xpos,
$ypos,
$font_size
  )
  =(
     100,
     700,
     12
  );


==> b1375 <==
          # S1
          $self->{'col_ids'} ||=
            [
               $self->numbering .. $self->width() + $self->numbering - 1 ]
            if ( defined( $self->width() ) && $self->width() > 0 );

          # S2
          $self->{'col_ids'} ||=
            [
               $self->numbering .. $self->width() + $self->numbering - 1 ]
            if ( defined( $self->width() ) && $self->width() > 0 );

==> b1376 <==
            # S1
            unless (
                  opendir ( CATDIR, $catdir ) )

              # S2
              unless (
                  opendir ( CATDIR, $catdir ) )


==> b1378 <==
if
(
$biblio
->
{subtitle}
)
{
&newsubtitle
(
$biblionumber
,
$biblio
->
{subtitle}
,
)
;
}

==> b1379 <==
# S1
print star (
             'Sol',
             planet (
                      'Earth', moon ('Lunar')
             ), );

# S2
print star (
             'Sol',
             planet (
                      'Earth', moon ('Lunar'),
             ), );


==> b1381 <==
my $formatter = new HTML::FormatPS(
    'PaperSize'    => 'Letter',
    'LeftMargin'   => 20,            # in points
    'RightMargin'  => 20,            # ditto
    'TopMargin'    => 10,
    'BottomMargin' => 30,
    'FontFamily'   => 'Helvetica',
);

my $formatter = new HTML::FormatPS(
    'PaperSize'    => 'Letter',
    'LeftMargin'   => 20,            # in points
    'RightMargin'  => 20,            # ditto
    'TopMargin'    => 10,
    'BottomMargin' => 30,
    'FontFamily'   => 'Helvetica',
);

==> b1384 <==
    eval{
        my@a=(foo=>'baz',bar=>'quux');
        validate(@a,{foo=>{regex=>qr/^baz$/},bar=>{regex=>'uqqx'}},
        );
    };

    eval{
        my@a=(foo=>'baz',bar=>'quux');
        validate(@a,{foo=>{regex=>qr/^baz$/},bar=>{regex=>'uqqx'}},
        );
    };


==> b1385 <==
(
    # optional glob
    {
        sub => 'sub26',
        p   => [
            foo => 1,
            bar => do { local *BAR; *BAR },
        ],
        expect => q{},
    },
);

(
    # optional glob
    {
        sub => 'sub26',
        p   => [
            foo => 1,
            bar => do { local *BAR; *BAR },
        ],
        expect => q{},
    },
);

==> b1386 <==
# S1
open(
      OUT,
      ">"
              . Bio::Root::IO->catfile(
                                        "t", "out.pfam"
              ),
);

# S2
open(
      OUT,
      ">"
              . Bio::Root::IO->catfile( "t",
                                        "out.pfam", ),
);

==> b1387 <==
unlink(
       Bio::Root::IO->catfile(
                    "t", "gcg.out"
       )
);

unlink(
       Bio::Root::IO->catfile(
           "t", "gcg.out", )
);

==> b1390 <==
    seek
      (
        FH,
        $end,
        0
        ,

      )
      ;

    seek
      (
        FH,
        $end,
        0

      )
      ;

==> b1392 <==
if (  ioctl (  STDERR, $TIOCGWINSZ,
               $winsize, )
  )
{
          ...;
}

if (  ioctl (  STDERR, $TIOCGWINSZ, $winsize
      )
  )
{
          ...;
}

==> b1393 <==
      push (
         @guaranteedata,
         {
   borrowernumber => $guarantees->[$i]->{'borrowernumber'},
   cardnumber => $guarantees->[$i]->{'cardnumber'},
   name => $guarantees->[$i]->{'firstname'} . " "
     . $guarantees->[$i]->{'surname'},
         }
      ) ;

      push (
         @guaranteedata,
         {
   borrowernumber => $guarantees->[$i]->{'borrowernumber'},
   cardnumber => $guarantees->[$i]->{'cardnumber'},
   name => $guarantees->[$i]->{'firstname'} . " "
     . $guarantees->[$i]->{'surname'},
         }
      ) ;

==> b1394 <==
SOAP::Transport::HTTP::Daemon->new (
                                    LocalAddr => $host,
                                    LocalPort => $port,
                                    Reuse => 1,
  )
  ->dispatch_with ({ 'urn:WishListCustomer' => 'WishListCustomer' } )
  ->objects_by_reference ('WishListCustomer')
  ->handle ;

SOAP::Transport::HTTP::Daemon->new (LocalAddr => $host,
                                    LocalPort => $port,
                                    Reuse => 1,)
  ->dispatch_with ({ 'urn:WishListCustomer' => 'WishListCustomer' } )
  ->objects_by_reference ('WishListCustomer')
  ->handle ;


==> b1395 <==
    # The old = break is under stress and must be ignored
                  if(my ($safari_build, $safari_minor) =
                        split /\./, $1)
                  {
                        ...;
                  }

                  if(my ($safari_build, $safari_minor) =
                        split /\./, $1)
                  {
                        ...;
                  }


==> b1396 <==
     print 'not '
       unless ( near (
            great_circle_distance ( 0, 0, 0, pi / 2 ), pi / 2
       ) );

     print 'not '
       unless ( near (
            great_circle_distance ( 0, 0, 0, pi / 2 ), pi / 2
       ) );


==> b1397 <==
         (
                  my $msg = sprintf (
                           gettext("%s: fatal error at line %d:\n"), $progname, $line
                      )
                      . "@_\n"
         ) =~ tr/\0//d;

         (
                  my $msg = sprintf (
                           gettext("%s: fatal error at line %d:\n"), $progname, $line
                      )
                      . "@_\n"
         ) =~ tr/\0//d;


==> b1399 <==
use constant GRAPH_SIZE => 100;
for ( my $i = 0 ;
      $i < @$data ;
      $i++ )
  {
     $polygon->addPt(
          ORIGIN_X_COORD
            + GRAPH_SIZE
            / ( @$data - 1 )
            * $i,
          ORIGIN_Y_COORD
            - $$data[$i]
            * GRAPH_SIZE
            / LOAD_MAX
     );
  } ## end for ( my $i = 0; $i < ...)

for ( my $i = 0 ;
      $i < @$data ;
      $i++ )
  {
     $polygon->addPt(
          ORIGIN_X_COORD
            + GRAPH_SIZE
            / ( @$data - 1 )
            * $i,
          ORIGIN_Y_COORD
            - $$data[$i]
            * GRAPH_SIZE
            / LOAD_MAX,
     );
  } ## end for ( my $i = 0; $i < ...)

==> b140 <==
$cmd[$i] =
  [ $s, $e, $cmd, \@hunk, $i ];

$cmd[$i] =
  [ $s, $e, $cmd, \@hunk, $i ];

==> b1401 <==
    my $moon_variation =
           0.6583 *
           sin(
        torad(
            2 *
                   (
                $moon_corrected_longitude
                       - $sun_lambda
                   ) ) );

    my $moon_variation =
           0.6583 *
           sin(
        torad(
            2 *
                   (
                $moon_corrected_longitude
                       - $sun_lambda
                   ) ) );


==> b1402 <==
ok (  3,
      int(
            at ( sum ( conv2d ( $b, $a, { Boundary => 'Reflect' } ) - $ans ) )
      ) == 0
);

ok (  3,
      int(
            at ( sum ( conv2d ( $b, $a, { Boundary => 'Reflect' } ) - $ans ) )
      ) == 0
);


==> b1403 <==
 $template->param(
  index        => $index,
  index2       => $index2,
  "f1_$result" => "f1_"
    . $result,
 );

 $template->param(
  index        => $index,
  index2       => $index2,
  "f1_$result" => "f1_" . $result
 );

==> b1404 <==
my %MyTokens= (
    '\tiny'       => { Type => 'local' },
    '\small'      => { Type => 'local' },
    '\scriptsize' => { Type => 'local' },
    '\footnotesize' =>
          { Type => 'local' },
);

my %MyTokens= (
    '\tiny'       => { Type => 'local' },
    '\small'      => { Type => 'local' },
    '\scriptsize' => { Type => 'local' },
    '\footnotesize' =>
          { Type => 'local' },
);

==> b1408 <==
          $registry->add_type_constraint(
              Moose::Meta::TypeConstraint::Parameterizable->new(
                   parent =>
                     Moose::Util::TypeConstraints::find_type_constraint( 'Ref' ),
                   constraint_generator => sub {

                             return sub {
                                       foreach my $x ( @$_ ) {
                                                 ( $check->( $x ) ) || return;
                                       }
                             }
                   }, ) );

          $registry->add_type_constraint(
              Moose::Meta::TypeConstraint::Parameterizable->new(
                   parent =>
                     Moose::Util::TypeConstraints::find_type_constraint( 'Ref' ),
                   constraint_generator => sub {

                             return sub {
                                       foreach my $x ( @$_ ) {
                                                 ( $check->( $x ) ) || return;
                                       }
                             }
                   }, ) );


==> b1409 <==
      local(%cached_env_img,%id_map,
            %symbolic_labels,%latex_labels,)
        if($FIXEDDIR&&$NO_SUBDIR);

      local(%cached_env_img,%id_map,%symbolic_labels,
            %latex_labels,)
        if($FIXEDDIR&&$NO_SUBDIR);

==> b1410 <==
my $line = join( LD_X, map { LD_H x ( $_ + 2 ) } @$widths );

my $line = join( LD_X, map { LD_H x ( $_ + 2 ) } @$widths );

==> b1413 <==
    &PDL::_conv2d_int(
        $a, $kern, $c,
        (  !( defined $opt
               && exists $$opt{Boundary} )
        ) ? 0 : (
            ( $$opt{Boundary} eq "Reflect"
            ) + 2 * ( $$opt{Boundary} eq "Truncate" )
        )
    );

    &PDL::_conv2d_int(
        $a, $kern, $c,
        (  !( defined $opt
               && exists $$opt{Boundary} )
        ) ? 0 : (
            ( $$opt{Boundary} eq "Reflect"
            ) + 2 * ( $$opt{Boundary} eq "Truncate" )
        )
    );

==> b1415 <==
if ( ioctl( STDERR, $TIOCGWINSZ,
            $winsize )
  )
{
    ...;
}

if ( ioctl( STDERR, $TIOCGWINSZ,
            $winsize )
  )
{
    ...;
}

==> b1419 <==
print(
     Tr(  td(  { -class => "forumTitle" },
               $info{"name"} )
     ),

);

print(
     Tr(  td(  { -class => "forumTitle" },
               $info{"name"} )
     ),

);

==> b1421 <==
if ( L2hos
     ->Link(
      $image2, $image1,
     ) )
{
L2hos
  ->Unlink($tmp);
}

if ( L2hos
     ->Link(
      $image2, $image1,
     ) )
{
L2hos
  ->Unlink($tmp);
}

==> b1422 <==
    $_ = (
        $INFO && $INFO =~ /^\d+$/
        ? join(
            '',
            $close_all,
"<STRONG>$t_title</STRONG><P>\nThis document was generated using the\n",
"<A HREF=\"$TEX2HTMLADDRESS\"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A>",
            " translator Version $TEX2HTMLVERSION\n",
            "<P>Copyright &#169; 1993, 1994, 1995, 1996,\n",
            "<A HREF=\"$AUTHORADDRESS\">Nikos Drakos</A>, \n",
            "Computer Based Learning Unit, University of Leeds.\n",
            "<BR>Copyright &#169; 1997, 1998, 1999,\n",
            "<A HREF=\"$AUTHORADDRESS2\">Ross Moore</A>, \n",
            "Mathematics Department, Macquarie University, Sydney.\n",
            "<P>The command line arguments were: <BR>\n ",
            "<STRONG>latex2html</STRONG> <TT>$argv</TT>\n",
            (
                ( $SHOW_INIT_FILE && ( $INIT_FILE ne '' ) )
                ? "\n<P>with initialization from: <TT>$INIT_FILE</TT>\n$init_file_mark\n"
                : ''
            ),
"<P>The translation was initiated by $address_data[0] on $address_data[1]",
            $open_all,
            $_,
          )
        : join(
            '',
            $close_all,
            "$INFO\n",
            $open_all,
            $_,
        )
    );


==> b1423 <==
                if ( L2hos
                     ->Link( $image2,
                             $image1,
                     )
                  )
                {
                    L2hos
                      ->Unlink($tmp);
                }

                if ( L2hos
                     ->Link( $image2,
                             $image1,
                     )
                  )
                {
                    L2hos
                      ->Unlink($tmp);
                }


==> b1424 <==
$registry->add_type_constraint( Moose::Meta::TypeConstraint::Parameterizable
                                  ->new( $a = 1;
                                         $b = 1;

                                  ) );

$registry->add_type_constraint( Moose::Meta::TypeConstraint::Parameterizable
                                  ->new( $a = 1;
                                         $b = 1;

                                  ) );


==> b1425 <==
my$sem=sub
{
    my$code=shift;
  }
  ->(sub
     {
         IPC::Semaphore->new(IPC_PRIVATE,$nsem,
                           S_IRWXU|S_IRWXG|S_IRWXO|IPC_CREAT);
     } );

my$sem=sub
{
    my$code=shift;
  }
  ->(sub
     {
         IPC::Semaphore->new(IPC_PRIVATE,$nsem,
                           S_IRWXU|S_IRWXG|S_IRWXO|IPC_CREAT);
     } );


==> b1426 <==
        return
          $self->_mutate($label,$newseq,$length,);

        return
          $self->_mutate($label,$newseq,$length,);

==> b1427 <==
print join( "\n",
            @intersection,
  ),
  "\n";

print join( "\n",
            @intersection,
  ),
  "\n";

==> b1428 <==
         is(
              grep ( { $_->{branchcode} eq 'MYLIBRARY' and $_->{selected} == 1 }
                      @$libraries ),
              1,
              'Without selected parameter, my library should be preselected',
         );

         is(
              grep ( { $_->{branchcode} eq 'MYLIBRARY' and $_->{selected} == 1 }
                      @$libraries ),
              1,
              'Without selected parameter, my library should be preselected',
         );

==> b1430 <==
         $t->post_ok(
                  "//$auth_userid:$password@/api/v1/advanced_editor/macros" =>
                          json => $macro_values )
                 ->status_is(400)
                 ->json_is( '/errors' => [ {
                  message => "Read-only.", path => "/body/macro_id",
                 } ] );

         $t->post_ok(
                  "//$auth_userid:$password@/api/v1/advanced_editor/macros" =>
                          json => $macro_values )
                 ->status_is(400)
                 ->json_is( '/errors' => [ {
                  message => "Read-only.", path => "/body/macro_id",
                 } ] );


==> b1431 <==
            C4::Circulation::AddRenewal(
                             $issue->{
                                'borrowernumber'},    # borrowernumber
                             $item->itemnumber,
                             undef, undef,
                             $circ->{'date'},
            ) unless ($DEBUG);

            C4::Circulation::AddRenewal(
                             $issue->{
                                'borrowernumber'},    # borrowernumber
                             $item->itemnumber,
                             undef, undef,
                             $circ->{'date'},
            ) unless ($DEBUG);

==> b1432 <==
$last = after (
                7,
                sub { print "not ok 3\n"; },
);

$last = after (
                7,
                sub { print "not ok 3\n"; },
);


==> b1433 <==
    return (
        ( $val || !exists $opts{$opt} ) ?
          do { $opts{$opt} = 1 } :
          do { delete $opts{$opt}; 1 }
    );

    return (
        ( $val || !exists $opts{$opt} ) ?
          do { $opts{$opt} = 1 } :
          do { delete $opts{$opt}; 1 }
    );

==> b1435 <==
(-r _)?
       do{do$vshnurc;&err($@)}:
       &err(
    "Cannot read $vshnurc")
       if-f$vshnurc;

(-r _)?
       do{do$vshnurc;&err($@)}:
       &err(
    "Cannot read $vshnurc")
       if-f$vshnurc;


==> b1436 <==
    if (
           $included{'gold'}
        && $yes_andor =~ /any/
        && $not_andor !~ /all/
        && (
            grep ( { $included{$_} } @COLORS ) +
            grep ( { $excluded{$_} } @COLORS ) ) == 5
            )
    {
    }

    if (
           $included{'gold'}
        && $yes_andor =~ /any/
        && $not_andor !~ /all/
        && (  grep ( { $included{$_} } @COLORS )
            + grep ( { $excluded{$_} } @COLORS ) ) == 5
            )
    {
    }

==> b1439 <==
                $pt +=
                  ( 0.1734 - 0.000393 * $t ) * dsin($m) +
                  0.0021 * dsin( 2 * $m )
                  - 0.4068 * dsin($mprime) +
                  0.0161 * dsin( 2 * $mprime )
                  - 0.0004 * dsin( 3 * $mprime ) +
                  0.0104 * dsin( 2 * $f )
                  - 0.0051 * dsin( $m + $mprime )
                  - 0.0074 * dsin( $m - $mprime ) +
                  0.0004 * dsin( 2 * $f + $m )
                  - 0.0004 * dsin( 2 * $f - $m )
                  - 0.0006 * dsin( 2 * $f + $mprime ) +
                  0.0010 * dsin( 2 * $f - $mprime ) +
                  0.0005 * dsin( $m + 2 * $mprime );

                $pt +=
                  ( 0.1734 - 0.000393 * $t ) * dsin($m) +
                  0.0021 * dsin( 2 * $m ) -
                  0.4068 * dsin($mprime) +
                  0.0161 * dsin( 2 * $mprime ) -
                  0.0004 * dsin( 3 * $mprime ) +
                  0.0104 * dsin( 2 * $f ) -
                  0.0051 * dsin( $m + $mprime )
                  - 0.0074 * dsin( $m - $mprime ) +
                  0.0004 * dsin( 2 * $f + $m ) -
                  0.0004 * dsin( 2 * $f - $m )
                  - 0.0006 * dsin( 2 * $f + $mprime ) +
                  0.0010 * dsin( 2 * $f - $mprime ) +
                  0.0005 * dsin( $m + 2 * $mprime );

==> b1440 <==
        $comp = (
            $form->[3] ?
                  (
                $im3->dummy( 0, 3 ) > 0 ) *
                  255 :
                  ( $im3 > 0 ) );

        $comp = (
            $form->[3] ?
                  (
                $im3->dummy( 0, 3 ) > 0 ) *
                  255 :
                  ( $im3 > 0 ) );

==> b1441 <==
    my $my_handler =
       new XML::Handler::YAWriter ( 'Output' => $fileHandler,

       );

    my $my_handler =
       new XML::Handler::YAWriter ( 'Output' => $fileHandler,

       );


==> b1442 <==
                $tmpstr = sprintf (
                    $self->jump_to_selected_sformat(),
                    $_,
                );

                $tmpstr = sprintf (
                    $self->jump_to_selected_sformat(),
                    $_,
                );

==> b1443 <==
        @matches = map {
            $pk = $_ . '::';
            grep ( /^\w+$/ && (
                    $sym = "${pk}$_", defined *$sym{CODE},

                ),
                keys %$pk );
        } _search_ISA($pkg);

        @matches = map {
            $pk = $_ . '::';
            grep ( /^\w+$/ && (
                    $sym = "${pk}$_", defined *$sym{CODE},

                ),
                keys %$pk );
        } _search_ISA($pkg);


==> b1444 <==
                  while (  my ( $k, $v )
                           = each %{
                                    $self->{channels}->{$chk}->{device_cache}
                           }
                         )
                  {
                           ...;
                  }

                  while (  my ( $k, $v )
                           = each %{
                                    $self->{channels}->{$chk}->{device_cache}
                           }
                         )
                  {
                           ...;
                  }


==> b1445 <==
         $cfg
                  ->
                  {
                  $type
                  }
                  [$num
                  ]
                  or
                  die
"Unrecognized $type number: $num\n";

         $cfg
                  ->
                  {
                  $type
                  }
                  [$num
                  ]
                  or
                  die
"Unrecognized $type number: $num\n";

==> b1446 <==
     serverprint(
         $d,
         &X::newxCreateGlyphCursorReq($cursor=&next_resource_id,
                                      $c,# sourcefont
                                      $c,# maskfont
                                      $ch,# sourcechar
                                      $ch+1,# maskchar
                                      $fr,$fg,$fb,
                                      $br,$bg,$bb
         )
     );

     serverprint(
         $d,
         &X::newxCreateGlyphCursorReq($cursor=&next_resource_id,
                                      $c,# sourcefont
                                      $c,# maskfont
                                      $ch,# sourcechar
                                      $ch+1,# maskchar
                                      $fr,$fg,$fb,
                                      $br,$bg,$bb
         )
     );

==> b1447 <==
    ok(defined($seqio=
                  $gb->get_Stream_by_batch([qw(J00522 AF303112
                 2981014)] )
    ));

    ok(defined($seqio=
                  $gb->get_Stream_by_batch([qw(J00522 AF303112
                 2981014)] )
    ));

==> b1448 <==
       $save_check =
                $menu_frame->Checkbutton(
                                          -variable => \$root->{'modified'},
                                          ( $os ne 'win' ? ( -selectcolor => "red" ) : () ),
                                          -highlightthickness => 0,
                                          -padx               => 0,
                                          -pady               => 0,

                                          #-font => "times 5",
                );

       $save_check =
                $menu_frame->Checkbutton(
                                          -variable => \$root->{'modified'},
                                          ( $os ne 'win' ? ( -selectcolor => "red" ) : () ),
                                          -highlightthickness => 0,
                                          -padx               => 0,
                                          -pady               => 0,

                                          #-font => "times 5",
                );


==> b1449 <==
    return wantarray
      ? map $_->(),
      @data
      : ( defined(wantarray) ? sub { $_[0] } : sub { print $_[0] } )
      ->( join( "\n", map $_->(), @data ) . "\n" );

    return wantarray
      ? map $_->(),
      @data
      : ( defined(wantarray) ? sub { $_[0] } : sub { print $_[0] } )
      ->( join( "\n", map $_->(), @data ) . "\n" );


==> b1450 <==
                    if (      $x
                              || (      ($self->allele_ori eq 'g')
                                        && (      substr($self->dnStreamSeq, -1, 1,) eq
                                                  'c')))
                    {
                              return 1;
                    }

                    if (      $x
                              || (      ($self->allele_ori eq 'g')
                                        && (      substr($self->dnStreamSeq, -1, 1,) eq
                                                  'c')))
                    {
                              return 1;
                    }

==> b1451 <==
my %distance_pref =
        (
        meter => 1.1,
        inch  => 0.7,
        foot  => 0.9,
        yard  => 0,
        mile  => 1.0,
        );

my %distance_pref =
        (
        meter => 1.1,
        inch  => 0.7,
        foot  => 0.9,
        yard  => 0,
        mile  => 1.0,
        );


==> b1453 <==
my $foo =
          decode_json( {
              foo => 'bar' }
          );

my $foo =
          decode_json( {
              foo => 'bar' }
          );

==> b1454 <==
my $red_color =
      $widget->window->get_colormap->color_alloc( {
                                                    red   => 65000,
                                                    green => 0,
                                                    blue  => 0
      } );

my $red_color =
      $widget->window->get_colormap->color_alloc( {
                                                    red   => 65000,
                                                    green => 0,
                                                    blue  => 0
      } );

==> b1455 <==
if ($BOLD_MATH) {
    (
       $labels, $comment,
       join( '',
                 '<B>', &make_math ( $mode, '', '', $_ ),
                 '</B>' ),
    )
}

if ($BOLD_MATH) {
    (
       $labels, $comment,
       join( '',
                 '<B>', &make_math ( $mode, '', '', $_ ),
                 '</B>' ),
    )
}

==> b1456 <==
                    $resources->{$group_id} =
                      {
                         id => $group_id, ident => $group_ident,
                         firstname   => $user->{firstname},
                         lastname    => $user->{lastname},
                         email       => $user->{email},
                         timezone_id => $user->{timezone_id},
                         name        => $user->{firstname} .
                           " " . $user->{lastname}, selected => '0',
                      };

                    $resources->{$group_id} =
                      {
                         id => $group_id, ident => $group_ident,
                         firstname   => $user->{firstname},
                         lastname    => $user->{lastname},
                         email       => $user->{email},
                         timezone_id => $user->{timezone_id},
                         name        => $user->{firstname} .
                           " " . $user->{lastname}, selected => '0',
                      };

==> b1457 <==
BEGIN {
         %messages=(
                  0x95 => [
                           StartSessionTransmission =>
                                    qw( *_RemoteIPAddr V_SessionType )
                  ],
                  0x93 => [
                           ConfigStat =>qw( Z16_DeviceName V_StationUserID
                                    V_StationUserInstance
                                    Z16_UserName Z16_ServerName
                                    V_NumberLines V_NumberSpeedDials )
                  ],
         ) ;
}

BEGIN {
         %messages=(
                  0x95 => [
                           StartSessionTransmission =>
                                    qw( *_RemoteIPAddr V_SessionType )
                  ],
                  0x93 => [
                           ConfigStat =>qw( Z16_DeviceName V_StationUserID
                                    V_StationUserInstance
                                    Z16_UserName Z16_ServerName
                                    V_NumberLines V_NumberSpeedDials )
                  ],
         ) ;
}


==> b1458 <==
     join( '',
          grep { defined }
           @{ $me->{'mail_hdr_list'} }
     );

     join( '',
          grep { defined }
           @{ $me->{'mail_hdr_list'}
           }, );

==> b1459 <==
# S1
my @pics=
 grep( -f "$dir/$_"
    &&-s "$dir/$_"
    &&!
    -f "$dir/$_$NO_ALBUM"
    &&!/\Q$NOT_IMG\E$/
    &&!/\Q$NO_ALBUM\E$/
    &&!/\.txt$/
    &&!/\.htaccess$/
    &&!/~$/
    &&$_ ne
"$opt->{'index'}$HTML"
    &&$_ ne $HEADER
    &&$_ ne $FOOTER
    &&

    $_ ne
    $opt->{'captions'},
   @dir ) ;

#S2
my @pics=
 grep( -f "$dir/$_"
    &&-s "$dir/$_"
    &&!
    -f "$dir/$_$NO_ALBUM"
    &&!/\Q$NOT_IMG\E$/
    &&!/\Q$NO_ALBUM\E$/
    &&!/\.txt$/
    &&!/\.htaccess$/
    &&!/~$/
    &&$_ ne
"$opt->{'index'}$HTML"
    &&$_ ne $HEADER
    &&$_ ne $FOOTER
    &&

    $_ ne
    $opt->{'captions'},
   @dir ) ;


==> b146 <==
# State 1

sub bubba {
    while (1) {
        if ( $#{ $i_cond->[ 1 ] } >= 0 ) {
            ( $return, $val ) =
                  exec_stmt (
                $i_cond->[ 1 ] );
        } } }

__END__
# State 2

sub bubba {
    while (1) {
        if ( $#{ $i_cond->[ 1 ] } >= 0 ) {
            ( $return, $val ) =
                  exec_stmt ( $i_cond->[ 1 ] );
        } } }

==> b1460 <==
  # S1;
  diag "Connected to "
        . inet_ntoa (
                     ( unpack_sockaddr_in (
                             getpeername(T)
                     ) )[1] ) . "\n";

  # S2
  diag "Connected to "
        . inet_ntoa (
                     ( unpack_sockaddr_in (
                             getpeername(T)
                     ) )[1] ) . "\n";


==> b1461 <==
        $C_sigmas = sub
        { [ $a3::COMMON, $a3::Offset{lcount} + 47 ] };

        $C_sigmas = sub
        { [ $a3::COMMON, $a3::Offset{lcount} + 47 ] };

==> b1462 <==
die sprintf(
     "Usage: %s [ -r | -a | -f fmt ] file ...\n",
     (
       $0=~
         m|.*/(.*)|o
     ),

);

die sprintf(
     "Usage: %s [ -r | -a | -f fmt ] file ...\n",
     (
       $0=~
         m|.*/(.*)|o
     ),

);

==> b1463 <==
die sprintf(
    "Usage: %s [ -r | -a | -f fmt ] file ...\n",
    (
       $0 =~
         m|.*/(.*)|o
    ),

);

die sprintf(
    "Usage: %s [ -r | -a | -f fmt ] file ...\n",
    (
       $0 =~
         m|.*/(.*)|o
    ),

);

==> b1464 <==
while ( $^O !~ /Win32/ and
    my $pid = fork() ) {
    my $status = waitpid $pid, 0;
    warn "Server restarting in $config->{delay} seconds";
    sleep $config->{delay};
}

==> b1465 <==
# See initialize_lp_*

my @pics =
         grep ( -f "$dir/$_"
                  && -s "$dir/$_"
                  &&              # Not zero byte file
                  !-f "$dir/$_$NO_ALBUM"
                  &&              # Don't show these
                  !/\Q$NOT_IMG\E$/
                  &&              # The not_img files themselves
                  !/\Q$NO_ALBUM\E$/
                  &&              # The not_img files themselves
                  !/\.txt$/ &&    # Per image captions
                  !/\.htaccess$/
                  &&              # httpd security files
                  !/~$/ &&        # Emacs backup files
                  $_ ne
"$opt->{'index'}$HTML"
                  &&                 # Index html
                  $_ ne $HEADER &&   # Header/footer
                  $_ ne $FOOTER
                  && $_ ne
                  $opt->{'captions'}
         ,                           # Captions file
         @dir );


==> b1466 <==
sub new{
     my($self)=$class->SUPER::new(
          yyrules=>[
               ['$start',2,undef,],
               [
                    'item',3,
                    sub{
                         if($_[3]){
                              my($k,$v,);
                              while(($k,$v,)=each(%{$_[3]})){
                                   if($k eq"email_"){
                                        if(
                                            defined$groups{$_[1]}
                                            ->{"email_work"})
                                        {
                                             $k="email_home";
                                        }
                                        else{
                                             $k="email_work";
                                        }
                                   }

                                   $groups{$_[1]}->{$k}=$v;
                              }
                         }
                    },
               ],
               [
                    '@1-3',
                    0,
                    sub{parse_value($_[2]->{ENCODING});},
               ],
               ['params',0,sub{{}},],
               [
                    'params',
                    3,
                    sub{
                         my%hash;
                         for(my$i=0;$i<@{$_[3]};$i+=2){
                              push@{$hash{$_[3]->[$i]}},$_[3]->[$i+1];
                         }
                         \%hash;
                    },
               ],
               [
                    'paramlist',
                    1,
                    sub{$_[1]},
               ],
               [
                    'paramlist',
                    5,
                    sub{
                         unshift(@{$_[1]},@{$_[5]},)if defined$_[5];
                         $_[1];
                    },
               ],
               [
                    'param',
                    5,
                    sub{[uc($_[1]),uc($_[5]),]},
               ],
               ['addressparts',1,sub{{"address",$_[1],}},],
               [
                    'addressparts',
                    3,
                    sub{{"address",$_[1],"address2",$_[3],}},
               ],
               [
                    'addressparts',
                    5,
                    sub{{"address",$_[1],"address2",$_[3],"street",$_[5],}},
               ],
          ],
          @_,
     );
     bless($self,$class,);

}

==> b1467 <==
      my $self = [
            {     receive  => 1,
                  transmit => 2,
            }];

      my $self = [
            {     receive  => 1,
                  transmit => 2,
            }];

==> b1468 <==
foreach $n (
     qw( msm ali ) )
{    foreach $e ( qw(
          uc16
          ) )
     {
          #
     }
}

foreach $n (
     qw( msm ali ) )
{    foreach $e ( qw(
          uc16
          ) )
     {
          #
     }
}

==> b1469 <==
my @outer =
        (
         [
          'a1', 'a2', 'a3',
         ], [
          'b1', 'b2', 'b3',
         ], [
          'c1', 'c2', 'c3',
         ],
        );

my @outer =
        (
         [
          'a1', 'a2', 'a3',
         ], [
          'b1', 'b2', 'b3',
         ], [
          'c1', 'c2', 'c3',
         ],
        );

==> b1470 <==
         $opt= {
                  iparse(  { Maxiter => 200, Eps => 1e-4, }, ifhref($opt) )
         };

         $opt= {
                  iparse(  { Maxiter => 200, Eps => 1e-4, }, ifhref($opt) )
         };

==> b1471 <==
my @global_ops = (
    { "|" => sub { $_[0] unless $_[1]; } },
    { "&" => sub { ( $_[0] && $_[1] ) ? $_[0] : 0; } },
);

my @global_ops = (
    { "|" => sub { $_[0] unless $_[1]; } },
    { "&" => sub { ( $_[0] && $_[1] ) ? $_[0] : 0; } },
);

==> b1474 <==
         $opt = {
                  iparse(  {Maxiter => 200, Eps => 1e-4,}, ifhref($opt) )
         };
         $opt = {
                  iparse(  {Maxiter => 200, Eps => 1e-4,}, ifhref($opt) )
         };

==> b1475 <==
run_sub (
         ->$blah{ say "ok 5" ; } ) ;

run_sub (
         ->$blah{ say "ok 5" ; } ) ;


==> b1476 <==
        $apply->configure(
            -command => sub {
                get_button_values_from_panel();
                execute_decors(0);
                set_unsaved();
            },
        );

        $apply->configure(
            -command => sub {
                get_button_values_from_panel();
                execute_decors(0);
                set_unsaved();
            },
        );

==> b148 <==
# state 1
@yydgoto=(
    1,25,140,86,36,129,141,155,90,159,28,82,38,48,
    132,40,91,147,134,151,160,29,130,77,78,158,30,
);

# state 2
@yydgoto=(
    1,25,140,86,36,129,141,155,90,159,28,82,38,48,
    132,40,91,147,134,151,160,29,130,77,78,158,30,
);


==> b1481 <==
$hr->set_uri_schemes([
 'http','https',
 undef,'ftp'
] );
$hr->set_uri_schemes([
 'http','https',
 undef,'ftp'
] );


==> b1482 <==
@ISA =
      qw(
    Net::FTP::I) ;

@ISA =
      qw(Net::FTP::I
      ) ;

==> b1485 <==
use
  UnixODBC qw(
         :all);
use
  UnixODBC qw(
         :all);

==> b1487 <==
use Net::Domain qw(hostname domainname
                   hostdomain);
use Net::Domain qw(hostname domainname
                   hostdomain);

==> b1488 <==
use vars qw($VERSION @ISA
            @EXPORT_OK %EXPORT_TAGS);
use vars qw($VERSION @ISA
            @EXPORT_OK %EXPORT_TAGS);

==> b1489 <==
    $menuitem_dict->signal_connect (
        'activate' => sub { create_dict_window () } );
    $menuitem_dict->signal_connect (
        'activate' => sub { create_dict_window () } );

==> b1490 <==
$e_str->bind (
'<return>' => sub {$e_hnr->tabfocus if $e_hnr->can ( 'tabfocus' );} );
$e_str->bind (
'<return>' => sub {$e_hnr->tabfocus if $e_hnr->can ( 'tabfocus' );} );

==> b1491 <==
@ISA =
       qw(
    Stack )
       ; # inherit from Stack
@ISA =
       qw(
    Stack )
       ; # inherit from Stack

==> b1492 <==
        $col->configure (
            -command => sub { $t->configure (-background => $color); }
        );

        $col->configure (
            -command => sub { $t->configure (-background => $color); }
        );

==> b1493 <==
        $w->bind(
            '<Page_Down>' => sub { $t1->yview(scroll => 1, 'pages'); }
        );

        $w->bind(
            '<Page_Down>' => sub { $t1->yview(scroll => 1, 'pages'); }
        );

==> b1494 <==
        $b4->bind(
            '<1>' => sub { cset('D', 'HilightColorFore', "\$color"); }
        );

        $b4->bind(
            '<1>' => sub { cset('D', 'HilightColorFore', "\$color"); }
        );

==> b1495 <==
                        $line{amountoutstanding}=
                           sprintf( "%.2f",
                                    $accts->[ $i ]->{'amountoutstanding'}
                           );

                        $line{amountoutstanding}=
                           sprintf( "%.2f",
                                    $accts->[ $i ]->{'amountoutstanding'}
                           );

==> b1495a <==
$line{amountoutstanding} = sprintf( "%.2f",
         $accts->[$ixx]->{'amountoutstanding'}
);

$line{amountoutstanding} = sprintf( "%.2f",
         $accts->[$ixx]->{'amountoutstanding'}
);

==> b1496 <==
my @abc
     = qw( a b c d e
     );

my @abc
     = qw( a b c d e
     );

==> b1497 <==
    $c->CanvasBind (
        '<2>' => [sub { area_down (@_) }, \%pinfo],
    );
    $c->CanvasBind (
        '<2>' => [sub { area_down (@_) }, \%pinfo],
    );

==> b1498 <==
    $c->addtag(
                'active', 'withtag',
                ruler_make_tab( $c, $x, $y, $rinfo ),
    );
    $c->addtag(
                'active', 'withtag',
                ruler_make_tab( $c, $x, $y, $rinfo ),
    );

==> b1499 <==
    ( $_[0] < 0 ) ?
      -1 :
      (
        ( $_[0] > 0 ) ? 1 : 0 );

    ( $_[0] < 0 ) ?
      -1 :
      (
        ( $_[0] > 0 ) ? 1 : 0 );

==> b1500 <==
$config = {
    delay => 5,
    ppid  => $$,
};
$config = {
    delay => 5,
    ppid  => $$,
};

==> b1501 <==
my%S3d_url=(
   'emotif'=>$SGD_stem_url{'s3d'}
     .'seq_search.pl?db=emotif&gene=',
   'pfam'=>$SGD_stem_url{'s3d'}
     .'seq_search.pl?db=pfam&gene=',
   'pfam_uk'=>$SGD_stem_url{'s3d'}
     .'seq_search.pl?db=pfam&loc=uk&gene=',
   'pfam_us'=>$SGD_stem_url{'s3d'}
     .'seq_search.pl?db=pfam&loc=us&gene=',
   'blast_nr'=>$SGD_stem_url{'s3d'}.'getblast?db=nr&name=',
   'blast_est'=>$SGD_stem_url{'s3d'}.'getblast?db=est&name=',
   'blast_mammal'=>$SGD_stem_url{'s3d'}
     .'getblast?db=mammal&name=',
   'blast_human'=>$SGD_stem_url{'s3d'}
     .'getblast?db=human&name=',
   'blast_worm'=>$SGD_stem_url{'s3d'}
     .'getblast?db=worm&name=',
   'blast_yeast'=>$SGD_stem_url{'s3d'}
     .'getblast?db=yeast&name=',
   'blast_worm_yeast'=>$SGD_stem_url{'s3d'}
     .'getblast?db=worm&query=worm&name=',
   'patmatch'=>$SGD_stem_url{'s3d2'}.'grepmatch?',##comment
   'grepmatch'=>$SGD_stem_url{'s3d2'}.'grepmatch?',
   'pdb_neighbors'=>$SGD_stem_url{'s3d'}
     .'pdb_neighbors?id=CHAIN&gene=ORF_NAME'
);

==> b1502 <==
my $species =
        new Bio::Species(
    -classification => [ qw(
                sapiens Homo Hominidae Catarrhini Primates Eutheria
                Mammalia Vertebrata Chordata Metazoa Eukaryota
        ) ]
        );

==> b1503 <==
         open(
                  MEMINFO
                  )
                  ||
                  die
"can't open $MEMINFO: $!";
         open(
                  MEMINFO
                  )
                  ||
                  die
"can't open $MEMINFO: $!";

==> b1504 <==
    my $FH = $self->_fh();

    while (<$FH>) {
        if ( $_ !~ /\w/ ) { next }
    }

==> b1507 <==
         while(($char=substr($t->{line},$t->{line_cursor}+1,1,))=~
               /[^\W\d_]/)
         {
                  ...;
         }

         while(($char=substr($t->{line},$t->{line_cursor}+1,1,))=~
               /[^\W\d_]/)
         {
                  ...;
         }


==> b1508 <==
open(
        FIND,
        "find $fslist $xdev -type f \\( -perm -04000 -o -perm -02000 \\) -print|",
);

open(
        FIND,
        "find $fslist $xdev -type f \\( -perm -04000 -o -perm -02000 \\) -print|",
);

==> b1509 <==
eval {
    $formatter->parse_from_file ( $file, $out_fh )
} ;
eval {
    $formatter->parse_from_file ( $file, $out_fh )
} ;

==> b156 <==
# State 1
{

    sub new_body_for
          {
        if ( defined $outname )
              {
            return MIME::Body::File->new (
                $parser->output_path ( $head ) );
              }
          }
}
__END__
# State 2
{

    sub new_body_for
          {
              if ( defined $outname )
              {
                  return MIME::Body::File
                  ->new (
                      $parser->output_path (
                          $head ) );
              }
          }
}

==> b163 <==
# State 1
Readonly::Scalar
       my$EXPL
       =>
       [
    71,
    72
       ]
       ;

# State 2

Readonly::Scalar
       my$EXPL
       =>
       [
    71,
    72
       ]
       ;


==> b172 <==
# State 1

my%invalid_defaults=
  (foo=>1,bar=>2, );

# state 2

my%invalid_defaults=
  (foo=>1,bar=>2,);

==> b173 <==
{

    $self->{_all_list_funcs}=
    {
        hashify keys%{$self->{_list_funcs}},
        keys%{$self->{_add_list_funcs}}
    };

}

{

    $self->{_all_list_funcs}=
    {
        hashify keys%{$self->{_list_funcs}},
        keys%{$self->{_add_list_funcs}}
    };

}

==> b174 <==
our %EXPORT_TAGS =
         (
    all =>
             \@EXPORT_OK,
         );

==> b177 <==
# State 1
Readonly::Array
       my@IGNORE_FOR_INTERPOLATION
       =>(
        q{$'},q{$$},
        q{$#},q{$:},
       );## no critic ( RequireInterpolationOfMetachars, ProhibitQuotedWordLists )

# State 2
Readonly::Array
       my@IGNORE_FOR_INTERPOLATION
       =>(
        q{$'},q{$$},
        q{$#},q{$:},
       );## no critic ( RequireInterpolationOfMetachars, ProhibitQuotedWordLists )


==> b183 <==
{
    {
        {
            {
                my $var=$parts[$i]->[0];
                if(             $var->isa('PPI::Token::Symbol')
                                ||$var->isa('PPI::Token::Cast'))
                {
                    return$TRUE
                      if _has_array_sigil($var);
                }
            }
        }
    }
}


==> b184 <==
Readonly::Hash my%CAPTURE_REFERENCE_ENGLISH=>
(     hashify(qw{ $LAST_PAREN_MATCH $LAST_MATCH_START $LAST_MATCH_END }),
      %CAPTURE_REFERENCE )
      ;

==> b186 <==
              # State 1
              if ($EVAL_ERROR)
                   { $errors->add_exception(
                            $self->_new_global_value_exception(
                                   option_name    => $option_name,
                                   option_value   => $theme_rule,
                                   source         => $source,
                                   message_suffix =>
                                        q{is not syntactically valid.},
                            )
                     );
                   }

              # State 2
              if ($EVAL_ERROR)
                   { $errors->add_exception(
                            $self->_new_global_value_exception(
                                   option_name    => $option_name,
                                   option_value   => $theme_rule,
                                   source         => $source,
                                   message_suffix =>
                                        q{is not syntactically valid.},
                            )
                     );
                   }

==> b191 <==
$specification=
{
    name=>'test',
    description=>'A boolean parameter for testing',
    behavior=>'boolean',
};

$specification=
{
    name=>'test',
    description=>'A boolean parameter for testing',
    behavior=>'boolean',
};


==> b192 <==
Readonly::Scalar
       my$EXPL
       =>
       [
    240,
    241
       ]
       ;

Readonly::Scalar
       my$EXPL
       =>
       [
    240,
    241
       ]
       ;


==> b194 <==
    return
      $length* $width
      * (
        log(
            sqrt(
                  ( $XSQP1* $YSQP1 )
                / ( 1 + $X* $X + $Y* $Y )
            )
          )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 )
      )
      * 2/ ( $pi* $X* $Y );

    return
      $length* $width
      * (
        log(
            sqrt(
                  ( $XSQP1* $YSQP1 )
                / ( 1 + $X* $X + $Y* $Y )
            )
          )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 )
      )
      * 2/ ( $pi* $X* $Y );


==> b198 <==
    # State 1
    return (
            log( sqrt( ( $XSQP1* $YSQP1 )/ ( 1 + $X* $X + $Y* $Y ) ) )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 ) )
      * 2/ ( $pi* $X* $Y );

    # State 2
    return (
            log( sqrt( ( $XSQP1* $YSQP1 )/ ( 1 + $X* $X + $Y* $Y ) ) )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 ) )
      * 2/ ( $pi* $X* $Y );

==> b199 <==
# State 1

{
         return(
                  log(sqrt(($XSQP1*$YSQP1)/(1+$X*$X+$Y*$Y)))
                    +$X*$RTYSQP1*atan2($X,$RTYSQP1)
                    +$Y*$RTXSQP1*atan2($Y,$RTXSQP1)
                    -$X*atan2($X,1)
                    -$Y*atan2($Y,1))
           *2/($pi*$X*$Y);
}

# State 2

{
         return(
                  log(sqrt(($XSQP1*$YSQP1)/(1+$X*$X+$Y*$Y)))
                    +$X*$RTYSQP1*atan2($X,$RTYSQP1)
                    +$Y*$RTXSQP1*atan2($Y,$RTXSQP1)
                    -$X*atan2($X,1)
                    -$Y*atan2($Y,1))
           *2/($pi*$X*$Y);
}

==> b203 <==
     # State 1
     local(%names)=(
              'JAN',1,'FEB',2,'MAR',3,'APR',4,
              'MAY',5,'JUN',6,'JUL',7,'AUG',8,
              'SEP',9,'OCT',10,'NOV',11,'DEC',12
     );

     # State 2
     local(%names)=(
              'JAN',1,'FEB',2,'MAR',3,'APR',4,
              'MAY',5,'JUN',6,'JUL',7,'AUG',8,
              'SEP',9,'OCT',10,'NOV',11,'DEC',12
     );


==> b205 <==
          if(testcmp({'-cmplines'=>\&msgcmp},$outfile,$cmpfile)){
                    ...;
          }

==> b215 <==
    # State 1
    local (%units)=(
           "in", "in", "pt","pt","pc", "pi",
           "mm", "mm","cm","cm","\\hsize", "%"
    );

    # State 2
    local (%units)=(
           "in", "in", "pt","pt","pc", "pi",
           "mm", "mm","cm","cm","\\hsize", "%"
    );

==> b224 <==
    # State 1
    my $newC =int(
             (
               $v{'y'}+5 -int($c->canvasy($y)) -5 * $v{'width'}
             )/10
    );

    # State 2
    my $newC =
         int(
             (
               $v{'y'}+5 -int($c->canvasy($y)) -5 * $v{'width'}
             )/10
         );

    # state 3
    my $newC =
         int(
             (
               $v{'y'}+5 -int($c->canvasy($y)) -5 * $v{'width'}
             )/10
         );

    # State 4 = 1

==> b225 <==
# State 1 (opened up)
{
    {
        {
            if(
                $IDXSIZE
                &&(
                    (   $i=(        $#MListOrder+1)-$IDXSIZE)>
                    0 )
              )
            {
                ...;
            }
        }
    }
}

# State 2 (tighter)

{
    {
        {
            if(
                $IDXSIZE
                &&(($i=(        $#MListOrder+1)-$IDXSIZE)>0)
              )
            {
                ...;
            }
        }
    }
}

==> b235 <==
	     foreach (sort(keys(%{ $gDtdGroups{$lDoctype} }))) {
		    ...;
		    }

==> b237 <==
                  # State 1
                  %args =
                    (
                      '_junk_',
                      split(/\n([^=]+)=/,$html_post_attributes)
                    );

                  # State 2

                  %args =
                    (
                      '_junk_',
                      split(/\n([^=]+)=/,$html_post_attributes)
                    );

                  # State 3
                  %args =
                    (
                      '_junk_',
                      split(/\n([^=]+)=/,$html_post_attributes)
                    );

                  # State 4
                  %args =
                    (
                      '_junk_',
                      split(/\n([^=]+)=/,$html_post_attributes)
                    );

                  # State 5 = State 1

                  %args =
                    (
                      '_junk_',
                      split(/\n([^=]+)=/,$html_post_attributes)
                    );

==> b242 <==
        unless (
                 $Printed{$index}
                 || (      $HasRef{$index}
                           && $TVisible{ $HasRef{$index} } )
             )

             unless (
                     $Printed{$index}
                     || (         $HasRef{$index}
                              && $TVisible{ $HasRef{$index} } )
             )

==> b249 <==
# State 1
sub parallel_plates_viewfactor {
       return $length * $width *
         (
              log( sqrt( ( $XSQP1 * $YSQP1 ) / ( 1 + $X * $X + $Y * $Y ) ) ) +
                $X * $RTYSQP1 * atan2( $X, $RTYSQP1 ) +
                $Y * $RTXSQP1 * atan2( $Y, $RTXSQP1 ) -
                $X * atan2( $X, 1 ) -
                $Y * atan2( $Y, 1 ) ) * 2 /
         ( $pi * $X * $Y );
}

==> b263 <==
    # State 1
    my $eps = [
        $eps_box_front, 0.99,        $eps_shield,
        $eps_shield,    $eps_shield, $eps_shield
    ];

    # State 2
    my $eps = [
        $eps_box_front, 0.99,        $eps_shield,
        $eps_shield,    $eps_shield, $eps_shield
    ];


==> b298 <==
# State 1
sub MAILhead_get_disposition
{
         local ( $disp,
                  $filename
           )
           = ( '',
                  '' );
}

__END__

# State 2
sub MAILhead_get_disposition
{
         local ( $disp,
                  $filename
           )
           = ( '',
                  '' );
}


==> b311 <==
# State 1

{
    return
      $length* $width
      * (
        log(
            sqrt(
                  ( $XSQP1* $YSQP1 )
                / ( 1 + $X* $X + $Y* $Y )
            )
          )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 )
      )
      * 2/ ( $pi* $X* $Y );
}

# State 2

{
    return
      $length* $width
      * (
        log(
            sqrt(
                  ( $XSQP1* $YSQP1 )
                / ( 1 + $X* $X + $Y* $Y )
            )
          )
          + $X* $RTYSQP1* atan2( $X, $RTYSQP1 )
          + $Y* $RTXSQP1* atan2( $Y, $RTXSQP1 )
          - $X* atan2( $X, 1 )
          - $Y* atan2( $Y, 1 )
      )
      * 2/ ( $pi* $X* $Y );
}

==> b317 <==
# State 1
my $xyz_b=
[
    [ 0, 0, $sepdis ],
    [ 1, 0, $sepdis ],
    [ 1, 1, $sepdis ],
    [ 0, 1, $sepdis ]
];

# State 2

my $xyz_b=
[
    [ 0, 0, $sepdis ],
    [ 1, 0, $sepdis ],
    [ 1, 1, $sepdis ],
    [ 0, 1, $sepdis ]
];

==> b357 <==
                        # State 1

                        if ()
                                {
                                ( $psect, $pcard ) =
                                        ( $sect, $card );
                                }

                        # State 2

                        if ()
                                {
                                ( $psect, $pcard ) =
                                        ( $sect, $card );
                                }

==> b358 <==
        # State 2
        &smsg( sprintf( "(autoloading %s from byte %07o)\n", $__fun__, $__addr__ ) )
              if $Start_Pid == $$ && &debugging('autoload');

        # State 2
        &smsg(
                sprintf( "(autoloading %s from byte %07o)\n", $__fun__,
                        $__addr__ )
        ) if $Start_Pid == $$ && &debugging('autoload');


==> b359 <==
    # State 1
    @NNVN_w3 = (
        Unclutters, Unfetters, Unifies,  Unites,
        Unseats,    Upgrades,  Upstages, Uses,
        Usurps, );

    # State 2
    @NNVN_w3 = (
        Unclutters, Unfetters, Unifies,  Unites,
        Unseats,    Upgrades,  Upstages, Uses,
        Usurps, );


==> b360 <==
# State 1
(
    $verbose, $showall,
    $short
     )
     = (
    $opt_v, $opt_V, $opt_s
     );

# State 2
(
    $verbose, $showall,
    $short
     )
     = (
    $opt_v, $opt_V, $opt_s
     );


==> b361 <==
# State 1
@cols = (
    \@row1, \@row2,
    \@row3 );

# State 2

@cols = (
    \@row1, \@row2,
    \@row3 );

==> b362 <==
        my@thou=
          ("",
            qw( M MM MMM	));

        my@thou=
          ("",
            qw( M MM MMM	));

==> b363 <==
# State 1
@_default_data{
    qw(_name	_artist	_publisher	_ISBN	_tracks	_rating
           _room	_shelf )
       }
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );

# State 2

@_default_data{
    qw(_name	_artist	_publisher	_ISBN	_tracks	_rating
           _room	_shelf )
       }
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );


==> b364 <==
# State 1

@_default_data[
       NAME,   ARTIST, PUBLISHER, ISBN,
       TRACKS, RATING, ROOM,      SHELF
       ]
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );

# State 2
@_default_data[
       NAME,   ARTIST, PUBLISHER, ISBN,
       TRACKS, RATING, ROOM,      SHELF
       ]
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );


==> b365 <==
# State 1
@_default_data[
       NAME,   ARTIST, PUBLISHER, ISBN,
       TRACKS, RATING, ROOM,      SHELF
       ]
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );

# State 2

@_default_data[
       NAME,   ARTIST, PUBLISHER, ISBN,
       TRACKS, RATING, ROOM,      SHELF
       ]
       = (
    '???', '???', '???', 0, '???', -1, "uncataloged", ""
       );

==> b366 <==

# State 1
%desc =
(blue  => "moon",
 green => "egg", red => "Baron",
);

# State 2
%desc =
(blue  => "moon",
 green => "egg", red => "Baron",
);


==> b367 <==
    # State 1
    %s2 =
    (   "cat" => 1, "dog" => 2, "gorilla" => 3,
        goldfish => 3 );

    # State 2
    %s2 =
    (   "cat" => 1, "dog" => 2, "gorilla" => 3,
        goldfish => 3 );


==> b368 <==
    # State 1
    my %args =
    (
        lines     => 23,            prompt => "--More--",
        endprompt => "--No more--", @_ );

    # State 2
    my %args =
    (
        lines     => 23,            prompt => "--More--",
        endprompt => "--No more--", @_ );


==> b369 <==
# State 1
my %sound =
(    "homo sapiens vendax" => "Have a nice day!",
     "h"                   => "???" );

# State 2
my %sound =
(    "homo sapiens vendax" => "Have a nice day!",
     "h"                   => "???" );


==> b370 <==
    # State 1
    $impl->{ lc $key } =
    {   key   => $key,
        value => $newval };

    # State 2
    $impl->{ lc $key } =
    {   key   => $key,
        value => $newval };

==> b371 <==
# State 1
@_index_for{
 qw(name	artist	publisher	ISBN	tracks	rating	room	shelf)
        } =
(  NAME, ARTIST, PUBLISHER, ISBN, TRACKS, RATING,
   ROOM, SHELF );

# State 2
@_index_for{
 qw(name	artist	publisher	ISBN	tracks	rating	room	shelf)
        } =
(         NAME, ARTIST, PUBLISHER, ISBN, TRACKS,
          RATING,
          ROOM, SHELF
);


==> b372 <==
# State 1

multimethod multi => (
    A_Parent, B_Parent, C_Parent
) => sub {
    print
"dispatched to &A_Parent::multi\n";
};

# State 2

multimethod multi => (
    A_Parent, B_Parent, C_Parent
) => sub {
    print
"dispatched to &A_Parent::multi\n";
};


==> b373 <==
# State 1

@sound{"mouse", "bird"}= (
    "ariba!","itortitawapuddytat"
);

# State 2

@sound{"mouse", "bird"}= (
    "ariba!","itortitawapuddytat"
);

==> b374 <==
# State 1
@virtues = (
    "faith", "hope", @deadly_sins );

# State 2
@virtues = (
    "faith", "hope", @deadly_sins );

==> b375 <==
# State 1
foreach
  (
    @very_long_list
  )
{
    if(
        $token
        ->can(
            "pretty_print"
        )
      )
    {
        ... ;
    }
}

# State 2

foreach
  (
    @very_long_list
  )
{
    if(
        $token
        ->can(
            "pretty_print"
        )
      )
    {
        ... ;
    }
}

==> b376 <==
# State 1

multimethod multi => (
    A_Child, B_Child, C_Child
) => sub {
    print
"dispatched to &A_Child::multi\n";
};

# State 2

multimethod multi => (
    A_Child, B_Child, C_Child
) => sub {
    print
"dispatched to &A_Child::multi\n";
};

==> b377 <==
# State 1
$graph->set(
     y_tick_number => 8,
     y_label_skip  => 2,
     bar_spacing   => 4,
     types         => [
           "bars",
           "linespoints"
     ],
);

# State 2

$graph->set(
     y_tick_number => 8,
     y_label_skip  => 2,
     bar_spacing   => 4,
     types         => [
           "bars",
           "linespoints"
     ],
);

==> b378 <==
# State 1

use constant BG_COLOR=>(
               255,255,255
);

# State 2

use constant BG_COLOR=>(
               255,255,255
);


==> b379 <==
# State 1
use
          constant
          AXIS_COLOR =>
          (
  0, 0, 0
          ) ;

# State 2
use
          constant
          AXIS_COLOR =>
          (
  0, 0, 0
          ) ;

==> b380 <==
# State 1
use constant BG_COLOR=>(
    255,255,255
);

# State 2
use constant BG_COLOR=>(
    255,255,255
);

==> b381 <==
         # state 1

         my$self={
                  firstName=>shift(),
                  lastName=>shift(),
         };

         # State 2
         my$self={
                  firstName=>shift(),
                  lastName=>shift(),
         };

==> b382 <==
# state 1
my$hash={
         "I'm a"=>" little tea cup",
         " short"=>" and stout..."
};

# state 2
my$hash={
         "I'm a"=>" little tea cup",
         " short"=>" and stout..."
};

==> b396 <==
# State 1

my $array3 =
  [ "anonymous",
    [ "array", "in", "an", "array" ],
    {  "plus" => "a",
       "hash" => "in",
    },
    "as", "well"
  ];

# State 2

my $array3 =
  [ "anonymous",
    [ "array", "in", "an", "array" ],
    {  "plus" => "a",
       "hash" => "in",
    },
    "as", "well"
  ];

==> b427 <==
# State 1
@items =
(   a ( {-href => "addforum.pl"}, "Add a Forum" ),
    "Delete a Forum",
    "Modify a Forum"
);

# State 2
@items =
(   a ( {-href => "addforum.pl"}, "Add a Forum" ),
    "Delete a Forum",
    "Modify a Forum"
);

==> b450 <==
my %reverse =
(
    "left"  => "right",
    "right" => "left",
    ""      => ""
);

my %reverse =
(
    "left"  => "right",
    "right" => "left",
    ""      => ""
);

==> b454 <==
# Complex
$diff = Math::BigFloat->new( (
      Math::BigFloat->new(
         ( Math::BigFloat
                     ->new(
               ( Math::BigFloat
                           ->new(
                     $China{gdp}
                              ->fmul
                              (
                        $China{gdp_incr}
                              ) )
               )
               ->fdiv(
                  Math::BigFloat
                           ->new(
                     $China{pop}
                              ->fmul
                              (
                        $China{pop_incr}
                              ) )
               ) ) )
         ->fsub( Math::BigFloat
                     ->new(
               ( Math::BigFloat
                           ->new(
                     $USA{gdp}
                              ->fmul
                              (
                        $USA{gdp_incr}
                              ) )
               )
               ->fdiv(
                  Math::BigFloat
                           ->new(
                     $USA{pop}
                              ->fmul
                              (
                        $USA{pop_incr}
                              ) )
               ) ) ) )
)->fabs() );


==> b455 <==
    # State 1

    %u =
      ( "cat"     => 1,
        "dog"     => 2,
        "gorilla" => 3,
        goldfish  => 3
      );

    # State 2

    %u =
      ( "cat"     => 1,
        "dog"     => 2,
        "gorilla" => 3,
        goldfish  => 3
      );

==> b496 <==
            my %package_details = ( LOCATION      => $loc,
                                    INST_DATE     => $instdate,
                                    INST_ROOT     => $root,
                                    INST_PACKLIST => $packlist,
                                    INST_PPD      => $ppd
            );

            my %package_details = ( LOCATION      => $loc,
                                    INST_DATE     => $instdate,
                                    INST_ROOT     => $root,
                                    INST_PACKLIST => $packlist,
                                    INST_PPD      => $ppd
            );

==> b499 <==
if (
/msie/
  )
{
          msie(
                    $_
            )
            ;
}

if (
/msie/
  )
{
          msie(
                    $_
            )
            ;
}

if (
/msie/
  )
{
          msie(
                    $_
            )
            ;
}

==> b507 <==
 # State 1
 my%all_options=(
                 %{$opt},
                 %{
                  $self->{DEFAULTS}
                 }
 );

 # State 2
 my%all_options=(
                 %{$opt},
                 %{
                  $self->{DEFAULTS}
                 }
 );

 # State 3
 my%all_options=
   (%{$opt},%{$self->{DEFAULTS}});

 # State 4
 my%all_options=
   (%{$opt},%{$self->{DEFAULTS}});

==> b511 <==
# State 1 (the - is type 'm' and did not have a bond strength)
$a
     =i
     - pdl(
    2, 3 );

# State 2
$a
     =i
     -pdl(
    2, 3 );

==> b520 <==
# State 1
my (
    $xp,
    $yp
 )
 = cursor (
    { Type =>
'CrossHair'
    });

# State 2
my (
    $xp,
    $yp
 )
 = cursor (
    { Type =>
'CrossHair'
    });

==> b523 <==
                foreach my $name (@$names)
                  { unless ($callcopy) { $ret .= <<"EOC" }
XX
EOC
                  }

                foreach my $name (@$names)
                  { unless ($callcopy) { $ret .= <<"EOC" }
XX
EOC
                  }

==> b527 <==
$w2->points(
    $x->index($ii),
    sqrt(
        $x->index(
            $ii) )
);

$w2->points(
    $x->index($ii),
    sqrt(
        $x->index(
            $ii) )
);

$w2->points(
    $x->index($ii),
    sqrt(
        $x->index(
            $ii) )
);

$w2->points(
    $x->index($ii),
    sqrt(
        $x->index(
            $ii) )
);

==> b530 <==
ok(
    tapprox( $a,
        $b )
);

ok(
    tapprox( $a,
        $b )
);


==> b534 <==
ok(
    int(
        $yp->at(0) )
              == 8
);

# State 2

ok(
    int(
        $yp->at(0) )
              == 8
);


==> b538 <==
WriteMakefile(
               'NAME'         => 'PDL',
               'VERSION_FROM' => 'Core/Version.pm',
               'PM'           => \%pm,
               'MAN3PODS'     => \%man3pods,
               'DIR'          =>
                 [ 'Pod',       'Gen',    'Core', 'Bad',  'Ops', 'Ufunc',
                   'Primitive', 'Slices', 'Test', 'Math', 'Complex'
                 ],
);

WriteMakefile(
               'NAME'         => 'PDL',
               'VERSION_FROM' => 'Core/Version.pm',
               'PM'           => \%pm,
               'MAN3PODS'     => \%man3pods,
               'DIR'          =>
                 [ 'Pod',       'Gen',    'Core', 'Bad',  'Ops', 'Ufunc',
                   'Primitive', 'Slices', 'Test', 'Math', 'Complex'
                 ],
);


==> b542 <==
my %init =
  ( i => {
           size => 'm_size',
           off  => 'poff',
           init => '1-p_size'
    },
    j => {
           size => 'n_size',
           off  => 'qoff',
           init => '1-q_size'
    },
  );

my %init =
  ( i => {
           size => 'm_size',
           off  => 'poff',
           init => '1-p_size'
    },
    j => {
           size => 'n_size',
           off  => 'qoff',
           init => '1-q_size'
    },
  );

==> b552 <==
        # State 1
        $entries->[$_] =
        { 'nextState' => $nextState,
          'flags'     => $flags };

        # State 2
        $entries->[$_] =
        { 'nextState' => $nextState,
          'flags'     => $flags };

==> b561 <==
sub insert_into_db {



 my (%sqlfuncs)
	    = (
		 'pgsql' => {
				  'func' => \&common_sql_insert,
				  'driver' => 'Pg',
				  'autocommit' => 0, },
		 'oracle' => {
				   'func' => \&common_sql_insert,
				   'driver' => 'Oracle',
				   'autocommit' => 0, },
		 'mysql' => {
				  'func' => \&common_sql_insert,
				  'driver' => 'mysql',
				  'autocommit' => 1, },);

 }


==> b604 <==
         if(
                  grep($_ eq 'STDIN',
                           @Ready)
         ){
                  ...;
         }

         if(
                  grep($_ eq 'STDIN',
                           @Ready)
         ){
                  ...;
         }

         if(
                  grep($_ eq 'STDIN',
                           @Ready)
         ){
                  ...;
         }


==> b605 <==
         # State 1

         if(
                  grep($_ eq 'STDIN',
                           @Ready)
         ){
                  ...;
         }

         # State 2

         if(
                  grep($_ eq 'STDIN',
                           @Ready)
         ){
                  ...;
         }

==> b610 <==
# State 1
elsif(
      $Directives{'sortingdata0'}eq"location/ call number")

__END__

# State 2
elsif($Directives{'sortingdata0'}eq
       "location/ call number")

==> b611 <==
    # State 1
    if (
        open(
            INFILE,
"$user_progs <$phone_out | $sort_progs |"
        ) )

        # State 2
          if (
        open(
            INFILE,
"$user_progs <$phone_out | $sort_progs |"
        ) )


==> b612 <==
    # State 1
    if(
        open(
            INFILE,
"$user_progs <$phone_out | $sort_progs |"
        ))

__END__

# State 2
    if
           (
        open
    (INFILE,
"$user_progs <$phone_out | $sort_progs |"
    ))

==> b613 <==
my%where=

(
	 Gary=>"Dallas",Lucy=>"Exeter",
	 Ian=>"Reading",Samantha=>"Oregon"
);

==> b614 <==
       if (
              open
              (
                     SAVE,
"> $msgfile"
              ) )


==> b616 <==
    my %hash= (Four => '4',
               Five => '5',
               Six => '6') ;
    my %hash= (Four => '4',
               Five => '5',
               Six => '6') ;


==> b617 <==
# State 1
{
    my (%reverse_genetic_code)
      =
      ( 'A' => 'GCA GCC GCG GCT',
        'C' => 'TGC TGT',
        'D' => 'GAC GAT',
      );
}

{
    my (%reverse_genetic_code)
      =
      ( 'A' => 'GCA GCC GCG GCT',
        'C' => 'TGC TGT',
        'D' => 'GAC GAT',
      );
}

==> b623 <==
                              # State 1
                              @hsp_datum =
                                (
                                    $hsp->range (
                                          'query'),
                                    $hsp->range (
                                          'sbjct') ) ;

                              # State 2
                              @hsp_datum =
                                (
                                    $hsp->range (
                                          'query'),
                                    $hsp->range (
                                          'sbjct') ) ;

==> b626 <==
unless (
    open( FILEHANDLE,
        $file ) )

       unless (
    open( FILEHANDLE,
        $file ) )

       unless (
    open( FILEHANDLE,
        $file ) )

==> b647 <==
        my ( $i,
                $len,
                $output
          )
          = ( 0,
                0, '' );

        my ( $i,
                $len,
                $output
          )
          = ( 0,
                0, '' );

==> b650 <==
%Bio::Tools::Sigcleave::WeightTable=
  (
 'H'=>
 [
  0,0,0,0,0,1,1,0,5,0,0,6,0,4,2,3.4
 ],
  );

%Bio::Tools::Sigcleave::WeightTable=
  (
 'H'=>
 [
  0,0,0,0,0,1,1,0,5,0,0,6,0,4,2,3.4
 ],
  );

==> b652 <==
                                        # State 1
                                        if ( $strand ==
                                             1 )
                                        {
                                             (
                                                  $insertbegin,
                                                  $insertend
                                                    )
                                                    = (
                                                  $self
                                                         ->
                                                         {
'seq'
                                                         }
                                                         ->
                                                         praeinsert_string(
                                                       $newseq,
                                                       $label
                                                         )
                                                    );
                                        }

                                        # State 2
                                        if ( $strand ==
                                             1 )
                                        {
                                             (
                                                  $insertbegin,
                                                  $insertend
                                                    )
                                                    = (
                                                  $self
                                                         ->
                                                         {
'seq'
                                                         }
                                                         ->
                                                         praeinsert_string(
                                                       $newseq,
                                                       $label
                                                         )
                                                    );
                                        }

==> b657 <==
if (
         defined (
                  $seqfile))


==> b689 <==
                                # require => to be in a list
                                has 'bar' =>
                                    ( is => 'ro', handles => qr/baz/, );

                                has 'bar' =>
                                    ( is => 'ro', handles => qr/baz/, );

==> b690 <==
coerce 'ArrayRefOfThings'=>from
     'ArrayRef[Int]'=>via
{[map{Thing->new(thing=>$_)}@{$_}]};

coerce 'ArrayRefOfThings'=>from
     'ArrayRef[Int]'=>via
{[map{Thing->new(thing=>$_)}@{$_}]};

==> b722 <==
# State 1
has 'baz' => (
    is      => 'ro',
    default => 'BAZ'
);

# State 2
has 'baz' => (
    is      => 'ro',
    default => 'BAZ'
);

==> b746 <==
# State 1 :
@eigenvalues=
  eigenvalue( [
        [ 3, 4 ], [ 4, -3 ]
  ] );

# State 2 :
@eigenvalues=
  eigenvalue( [
        [ 3, 4 ], [ 4, -3 ]
  ] );

@eigenvalues=
  eigenvalue( [
                [ 3,  4 ],
                [ 4, -3 ],
  ] );

__END__

# This is the state if welded
@eigenvalues= eigenvalue( [
   [ 3, 4 ], [ 4, -3 ] ] );

# State if no weld
@eigenvalues=
  eigenvalue(
     [
       [ 3, 4 ], [ 4, -3 ]
     ]
  );

==> b747 <==
 if ( @type
  = grep /$data/i,
  @Bio::Root::Err::ERR_TYPES
   )

==> b750 <==
                    # S1
                    $self->_testStrand( $other, $so )
                      and not(
                              ( $self->start() > $other->end()
                                        or $self->end() <
                                        $other->start() )
                      )

__END__
# S2
                    $self->_testStrand( $other, $so )
                      and not( (
                                    $self->start() > $other->end()
                                 or $self->end() < $other->start()
                      ) )


==> b751 <==
          # State 1
          unless (
                    ($genefeatureshash)
                    && (
                              scalar(
                                        @{ $genefeatureshash->{
'genefeatures'
                                        } } ) )
            )

            # State 2
            unless (
                    ($genefeatureshash)
                    && (
                              scalar(
                                        @{ $genefeatureshash->{
'genefeatures'
                                        } } ) )
            )

==> b752 <==
# S1
my$cmb=CPAN::Mirrored::By->new({
          continent=>"continent",
          country=>"country",
          http=>"http",
          ftp=>"ftp",
});

# S2
my$cmb=
  CPAN::Mirrored::By->new(
      {
        continent=>"continent",
        country=>"country",
        http=>"http",
        ftp=>"ftp",
      }
  );

==> b753 <==
# S1
my $parser =
  TAP::Parser->new( {
        iterator  => $iterator,
        callbacks => \%callbacks,
  } );

# S2
my $parser =
  TAP::Parser->new( {
        iterator  => $iterator,
        callbacks => \%callbacks,
  } );


==> b756 <==
                        # s1
                        if (
                                !utf8::is_utf8(
                                        $tab
                                                ->
                                                {lib}
                                ) )

                                # S2
                                if (
                                !utf8::is_utf8(
                                        $tab
                                                ->
                                                {lib}
                                ) )

==> b760 <==
    # State 1
    while (
        (
            my $tagfield,
            my $tagsubfield,
            my $liblibrarian,
            my $kohafield
        )
        = $sth->fetchrow
      )
      # State 2
      while (
        (
            my $tagfield,
            my $tagsubfield,
            my $liblibrarian,
            my $kohafield
        )
        = $sth->fetchrow
      )

==> b765 <==
# state 1
foreach
          my $name
          (
    param
              $query
          )

__END__

# state 2
foreach
          my $name
          (
    param $query)


==> b775 <==
    my @files = @ARGV =
      (
        File::Spec->catfile( 'ecmddir', $Testfile ),
        File::Spec->catfile( 'ecmddir', 'temp2', $Testfile )
      );

    my @files = @ARGV =
      (
        File::Spec->catfile( 'ecmddir', $Testfile ),
        File::Spec->catfile( 'ecmddir', 'temp2', $Testfile )
      );

    my @files = @ARGV =
      (
        File::Spec->catfile( 'ecmddir', $Testfile ),
        File::Spec->catfile( 'ecmddir', 'temp2', $Testfile )
      );

    my @files = @ARGV =
      (
        File::Spec->catfile( 'ecmddir', $Testfile ),
        File::Spec->catfile( 'ecmddir', 'temp2', $Testfile )
      );

==> b777 <==
# state 1
for (
    reverse
    map { $_ }
    @array
  )
{
    $r .= $_;
}

# state 2

for (
    reverse
    map { $_ }
    @array
  )
{
    $r .= $_;
}

==> b778 <==
    # S1
    my $smallest
      = (
        sort {
            (
                (
                    @q #
                )
            )
        }
      );

    # s2
    my $smallest
      = (
        sort {
            (
                (
                    @q #
                )
            )
        }
      );

==> b779 <==
    $_[0]
      ->end_code(
        pop(
            @{$_[0]->{'in_code'}}
        ));

    $_[0]
      ->end_code(
        pop(
            @{$_[0]->{'in_code'}}
        ));


==> b780 <==
for
  my $index(
    GZIP_MIN_HEADER_SIZE..
      GZIP_MIN_HEADER_SIZE
      + length($Name)
      -1)

__END__
for my $index(
			  GZIP_MIN_HEADER_SIZE..
			  GZIP_MIN_HEADER_SIZE
			  +length(
						 $Name)-
			  1)


==> b787 <==
# State 1: the +GZIP is parsed as type p
for my $index ( GZIP_MIN_HEADER_SIZE
      +1 .. GZIP_MIN_HEADER_SIZE
      -GZIP_FEXTRA_HEADER_SIZE
      +1 )

__END__

# State 2: all are type +
for my $index ( GZIP_MIN_HEADER_SIZE
    +1 .. GZIP_MIN_HEADER_SIZE +
    GZIP_FEXTRA_HEADER_SIZE
    +1 )

==> b789 <==
                  my $wd =
                         (
                           $self->splitpath( Cwd::getcwd(), 1 )
                         )[1];

                  my $wd = (
                           $self->splitpath( Cwd::getcwd(), 1 )
                  )[1];

==> b826 <==
    # State 1
    @tic_intervals =
      ( [ 'DECADE',     SECONDS_IN_YEAR, 10, 'y' ],
        [ 'HALFDECADE', SECONDS_IN_YEAR, 5,  'y' ],
        [ 'YEAR',       SECONDS_IN_YEAR, 1,  'y' ],
      );

    # State 2
    @tic_intervals =
      ( [ 'DECADE',     SECONDS_IN_YEAR, 10, 'y' ],
        [ 'HALFDECADE', SECONDS_IN_YEAR, 5,  'y' ],
        [ 'YEAR',       SECONDS_IN_YEAR, 1,  'y' ],
      );

    # State 3
    @tic_intervals =
      ( [ 'DECADE',     SECONDS_IN_YEAR, 10, 'y' ],
        [ 'HALFDECADE', SECONDS_IN_YEAR, 5,  'y' ],
        [ 'YEAR',       SECONDS_IN_YEAR, 1,  'y' ],
      );

    # State 4
    @tic_intervals =
      ( [ 'DECADE',     SECONDS_IN_YEAR, 10, 'y' ],
        [ 'HALFDECADE', SECONDS_IN_YEAR, 5,  'y' ],
        [ 'YEAR',       SECONDS_IN_YEAR, 1,  'y' ],
      );

    # State 5
    @tic_intervals =
      ( [ 'DECADE',     SECONDS_IN_YEAR, 10, 'y' ],
        [ 'HALFDECADE', SECONDS_IN_YEAR, 5,  'y' ],
        [ 'YEAR',       SECONDS_IN_YEAR, 1,  'y' ],
      );


==> b860 <==
# Alternately deleting blank after the =cut
#!/usr/bin/perl -w

=head1 NAME

Net::ICal::Recurrence -- Represent a single recurrence rule

=cut

package Net::ICal::Recurrence;


==> b862 <==
# State 1
sub _tz_dow {
return $oDoW[
             (
                 localtime(
                     $time
                     ->as_int )
             )[6]
    ];
}

# State 2 (changed sub name to avoid perltidy complaint)
sub _tz_doW {
return $oDoW[
             (
                 localtime(
                     $time
                     ->as_int )
             )[6]
    ];
}

==> b866 <==
# S1
if (    open( MAGIC,
                ">$magic" ) )

__END__
# S2
if
         ( open
( MAGIC, ">$magic" ) )

__END__


==> b872 <==
foreach
        my $key
        (
sort (
keys(
%{$self
        ->[
        $level]}
        )))

__END__

# S2
foreach my $key
        (sort (
 keys(
 %{
 $self->[
         $level]
         }
         )
         ))


==> b878 <==
	  my$data=pack(
		    "vvvvvC",
		    $colFirst,
		    $colLast,
		    $coldx,
		    $ixfe,
		    $grbit,
		    $reserved
	  );

	  my$data=pack(
		    "vvvvvC",
		    $colFirst,
		    $colLast,
		    $coldx,
		    $ixfe,
		    $grbit,
		    $reserved
	  );

	  my$data=pack(
		    "vvvvvC",
		    $colFirst,
		    $colLast,
		    $coldx,
		    $ixfe,
		    $grbit,
		    $reserved
	  );

	  my$data=pack(
		    "vvvvvC",
		    $colFirst,
		    $colLast,
		    $coldx,
		    $ixfe,
		    $grbit,
		    $reserved
	  );

	  my$data=pack(
		    "vvvvvC",
		    $colFirst,
		    $colLast,
		    $coldx,
		    $ixfe,
		    $grbit,
		    $reserved
	  );


==> b899 <==
explain
	  {
     1 => 1
	  } ;

explain
	  {
     1 => 1
	  } ;

==> b900 <==
${
    nucleic {
        $seq_name
    }
    ->{'seq'}
          }
          = $_;

# State 2
${
    nucleic {
        $seq_name
    }
    ->{'seq'}
          }
          = $_;


==> b901 <==
# State 1
@tagged_texts =
         walk_html(
                    $tree,
                    sub { [ 'MAYBE', $_[ 0 ] ] },
                    \&promote_if_h1tag
         );

# State 2
@tagged_texts = walk_html(
    $tree,
    sub
    {
        [ 'MAYBE', $_[ 0 ] ]
    },
    \&promote_if_h1tag
);

==> b903 <==
      # State 1
      @items[ $j +
          1 .. $#items
          ] =
          reverse
          @items[ $j +
          1 .. $#items
          ];

      # State 2
      @items[ $j +
          1 .. $#items
          ] =
          reverse
          @items[ $j +
          1 .. $#items
          ];


==> b904 <==
# State 1
        if
              (
            -t)

__END__

# State 2
        if
              (
            -t)

==> b905 <==
# state 1
    printf
          gettext
          (
        <<'EOF'), $progname;
Usage: %s [options] [changelog entry]
EOF

# state 2

    printf
          gettext
          (
        <<'EOF'), $progname;
Usage: %s [options] [changelog entry]
EOF


==> b908 <==
@spec = (
    [ 'stdout', *OUT, \$out ],
    [ 'stderr', *ERR, \$err ]
);

@spec = (
    [ 'stdout', *OUT, \$out ],
    [ 'stderr', *ERR, \$err ]
);


==> b909 <==
        # State 1
        $args{extra_linker_flags}=
          [
            File::Spec->catfile($self->perl_inc(),$lib),
            $self->split_like_shell($args{extra_linker_flags})
          ];

        # State 2
        $args{extra_linker_flags}=
          [
            File::Spec->catfile(       $self->perl_inc(),$lib ),
            $self->split_like_shell(   $args{extra_linker_flags})
          ];

        # State 3
        $args{extra_linker_flags}=
          [
            File::Spec->catfile($self->perl_inc(),$lib),
            $self->split_like_shell($args{extra_linker_flags})
          ];

==> b911 <==
# State 1
my$test=(
semctl(
-1,0,0,0
)
)[0];

# state 2
my$test=(
semctl(
-1,0,0,0
)
)[0];


==> b912 <==
    # State 1

    my @binary_by_priority
        = sort
    {
        (
            $Override{
                $a}
            ? $Priority{
                $Override{
                    $a}
                    [O_PRIORITY
                    ]
                }
            : 0 )
            <=> (
            $Override{
                $b}
            ? $Priority{
                $Override{
                    $b}
                    [O_PRIORITY
                    ]
                }
            : 0 )
    } @binary;

    # State 2

    my @binary_by_priority
        = sort
    {
        (
            $Override{
                $a}
            ? $Priority{
                $Override{
                    $a}
                    [O_PRIORITY
                    ]
                }
            : 0 )
            <=> (
            $Override{
                $b}
            ? $Priority{
                $Override{
                    $b}
                    [O_PRIORITY
                    ]
                }
            : 0 )
    } @binary;


==> b913 <==
# State 1
        elsif
              (
            -t)

__END__
# State 2
        elsif
              (
            -t)

==> b917 <==
# State 1
    print
          BODY
          &q
          (
        <<'EOT');
:	while ($ARGV[0] =~ /^-/) {
EOT

# State 2
    print
          BODY
          &q
          (
        <<'EOT');
:	while ($ARGV[0] =~ /^-/) {
EOT

==> b923 <==
# State 1
my %nodecount =

         (
    'attribute' => 0,
    'CDMS'      => 0,
    'comment'   => 0,
    'element'   => 0,
    'PI'        => 0,
    'text'      => 0,
         );

# State 2

my %nodecount =

         (
    'attribute' => 0,
    'CDMS'      => 0,
    'comment'   => 0,
    'element'   => 0,
    'PI'        => 0,
    'text'      => 0,
         );

==> b924 <==
foreach my $p(
        sort{lc($a)cmp lc($b)}
          keys%v
  )

__END__

foreach my $p(
        sort{lc($a)cmp lc($b)}
        keys%v
  )

==> b926 <==
my@str1=(
substr(
$strD,0,3
),
substr(
$strD,3,4
),
);

# state 2
my@str1=(
substr(
$strD,0,3
),
substr(
$strD,3,4
),
);

==> b928 <==
# State 1
${
    nucleic {
        $seq_name
    }
    {
        'seq'
    }
          } =
          $_;

# State 2

${
    nucleic {
        $seq_name
    }
    {
        'seq'
    }
          } =
          $_;


==> b929 <==
 # State 1: note that RELEASE_FILES is parsed as type G
 #2: @{
 #2: tL
 #3: ${ RELEASE_FILES {
 #3: tLbGGGGGGGGGGGGGb{
                  foreach my ${DISTRO}(
                           @{
                                    ${
                                             RELEASE_FILES {
                                                      $OS
                                             }
                                    }
                           }
                    )

 # State 2: note that RELEASE_FILES is parsed as type w
 #2: @{
 #2: tL
 #3: ${
 #3: tL
 #4: RELEASE_FILES
 #4: wwwwwwwwwwwww
                    foreach my ${DISTRO}(
                           @{
                                    ${
                                             RELEASE_FILES {
                                                      $OS
                                             }
                                    }
                           }
                    )

==> b930 <==
# State 1
$out
         .=StripHTML( $a, $pre, $indent,
                      $leftovers ) .
         "\n" .
         $$indent;

# State 2
$out
         .=StripHTML( $a, $pre, $indent,
                      $leftovers ) .
         "\n" .
         $$indent;


==> b931 <==
# State 1

print SAVEOUT ( $? & 127 ) ?
  " (SIG#" . ( $? & 127 ) . ")" : "",
  ( $? & 128 ) ? " -- core dumped" : "",
  "\n";

# State 2

print SAVEOUT ( $? & 127 ) ?
  " (SIG#" . ( $? & 127 ) . ")" : "",
  ( $? & 128 ) ? " -- core dumped" : "",
  "\n";

==> b932 <==
# s1
my @parts
  = decompose( '(\s+|/|\!|=)',
               $line, undef, 1, undef, '["\']' );

# S2
my @parts
  = decompose( '(\s+|/|\!|=)',
               $line, undef, 1, undef, '["\']' );


==> b933 <==
            # s1
            $tmp
              = &DateCalc_DateDelta( $date1,
                                     "+$dy:0:0:0:0:0:0", \$err,
                                     0 );

            # s2
            $tmp
              = &DateCalc_DateDelta( $date1,
                                     "+$dy:0:0:0:0:0:0", \$err,
                                     0 );


==> b934 <==
        #4: pi ()
        #4: CCb{}
        sub pi();

        if (
            $t >
            pi()
              )

              if
              (
            $t >
            pi()
              )

==> b935 <==
        @a =
                  multicall_return
                  {
            "one",
            "two"
                  }
                  $gimme;

        @a =
                  multicall_return
                  {
            "one",
            "two"
                  }
                  $gimme;

==> b936 <==
# S1
foreach my $x (
        sort{lc($a)cmp lc($b)}
          keys %INC
  )

__END__

# S2
foreach my $x (
        sort{
                lc($a)cmp
                  lc($b)
        }
        keys %INC
  )


==> b938 <==
                # S1: this is broken on input
                $features->{$name}=
                  {
                    description=>$origin->{$name}{description},
                    prereqs=>
                      _prereqs_from_1(undef,undef,$origin->{$name}
                      ), };

                # S2 : This is not broken
                $features->{$name}=
                  {
                    description=>$origin->{$name}{description},
                    prereqs=>_prereqs_from_1(undef,undef,$origin->{$name}), };

==> b939 <==
      # State 1
      if (not(-S $syslog_path or -c _)) {
            return 0;
      }

      # State 2
      if (not(-S $syslog_path or -c _)) {
            return 0;
      }

==> b940 <==
# S1

my@todo=
  (
[$top,\@lines]);

# S2
my@todo=
  (
[$top,\@lines]);


==> b941 <==
# S1

($a,$q,$b)=(
$b,$c->_div($a,$b)
);# step 1

# S2
($a,$q,$b)=(
$b,$c->_div($a,$b)
);# step 1

==> b943 <==
    @aa =
      $self
      ->_rearrange
      (
        [
            qw(EXPECT
              BITS
              FRAC
              SEQDESC
              SEQLENGTH
            )
        ],
        @args
      );

    @aa =
      $self
      ->_rearrange
      (
        [
            qw(EXPECT
              BITS
              FRAC
              SEQDESC
              SEQLENGTH
            )
        ],
        @args
      );

==> b945 <==
# State 1
if ($printmask
    [ $linen++ ]
	 )
{   }

# State 2
if ($printmask
    [ $linen++ ]
	 )
{   }

# State 3
if ($printmask
    [ $linen++ ]
	 )
{   }


==> b946 <==
if ($optf) {
    ($comp) =(
        split ' ', $comp, $optf +1
    )[$optf];
}


==> b947 <==
push @ARGV2 => [
         $dir, $intermediate++ ];


==> b948 <==
my (
    $who,
    $op,
    $perm
  )
  = (
    0, '',
    0
  );

==> b949 <==
push @{ $remember{ $operator }
  } => [
         $left, $right, $answer ];

__END__
push @{ $remember{ $operator }
  } =>
  [ $left, $right, $answer ];

==> b950 <==
{
    {
        ( $mode,
            $filename
                  )
                  =
                  (
            $1,
            $2
                  )
                  ;
    }
}

==> b951 <==
{
    {
        ( $mode,
            $filename )
                  = (
            $1, $2 );
    }
}


==> b952 <==
my %so = (
    'A' => 1,
    'J' => 11,
    'Q' => 12,
    'K' => 13
);

==> b953 <==
# State 1
*$self={
    %opts,lines=>[],scrap=>'',EOF=>0,
    count=>0,ends=>[],
};

# State 2
*$self={
    %opts,lines=>[],scrap=>'',EOF=>0,
    count=>0,ends=>[],
};

==> b954 <==
# State 1
*$self = {
%opts,
lines => [],
scrap => '',
EOF   => 0,
count => 0,
ends  => [],
};

# State 2
*$self = {
%opts,
lines => [],
scrap => '',
EOF   => 0,
count => 0,
ends  => [],
};
__END__

*$self = {
%opts,
lines => [],
scrap => '',
EOF   => 0,
count => 0,
ends  => [],
};


==> b956 <==
my ( $template, $loggedinuser, $cookie )
	   =get_template_and_user (
	{
		template_name => "parameters/stopwords.tmpl",
		query         => $input,
		type          => "intranet",
		flagsrequired =>
			   { parameters => 1, management => 1 },
		authnotrequired => 0,
		debug           => 1, } );


==> b958 <==
while (<>)
  {
 chomp ;
 $line=$_ ;

 if (    /\.start/
      or /\.next/ )
   {
  ( $keyword, $filename,
    $title
    )
    =trim ( split /\s/,
            trim ($line),
            3
            ) ;
  $line
    =$keyword
    . " "
    . $title ;
    }
 print "$line\n" ;
 }

==> b959 <==
{
    if (defined(
        $symbol_table{$direccion}
    ))
}

==> b960 <==
# State 1

$cron =
  pkgfile( $PACKAGE,
           "cron.$type"
  ) ;

# State 2

$cron =
  pkgfile( $PACKAGE,
           "cron.$type"
  ) ;

==> b961 <==
     my($u,$u1)=
        ( $self
             ->bzero(),
          $self->bone()
        );

     my($u,$u1)=
        ( $self
             ->bzero(),
          $self->bone()
        );

==> b962 <==
# State 1
{

    sub state1
          {
        if ( $x )
              {
            return MIME::Body::File->new (
                $parser->output_path ( $head ) );
              }

          }
}

# State 2

{

    sub state2
          {
        if ( $x )
              {
            return MIME::Body::File->new (
                $parser->output_path ( $head ) );
              }

          }
}

==> b963 <==
my @cellbits=
(
				 ['','   ','  +','','|','','','','  +'],
				 ['','  |','--+','','|','','','','--+'],
);

my @cellbits=
(
				 ['','   ','  +','','|','','','','  +'],
				 ['','  |','--+','','|','','','','--+'],
);

==> b964 <==
# State 1
$mult=
  (
        $coeffs->[$i]/
          2)+
  (     $x-
          $points[$i]
          [0])*
  (
        $coeffs->[$i+1]
          -$coeffs
          ->[$i])/
  (6*$delta);

# State 2

$mult=
  (
        $coeffs->[$i]/
          2)+
  (     $x-
          $points[$i]
          [0])*
  (
        $coeffs->[$i+1]
          -$coeffs
          ->[$i])/
  (6*$delta);

==> b965 <==
                           # State 1
                           if($codonTable->is_start_codon(
                                             substr($seq,
                                                      0,
                                                      3)))

                             # State 2
                             if($codonTable->is_start_codon(
                                             substr($seq,
                                                      0,
                                                      3)))

==> b966 <==
    # s1
    my @translations = (
        $self
          ->transexonscreation(
            $dna, \@transcripts
          )
    );

    # s2
    my @translations = (
        $self
          ->transexonscreation(
            $dna, \@transcripts
          )
    );

==> b967 <==
my (
    $primary) =
  $self
  ->_rearrange
  (
    [
        qw(PRIMARY
        )
    ],
    @args
  );

my (
    $primary) =
  $self
  ->_rearrange
  (
    [
        qw(PRIMARY
        )
    ],
    @args
  );

==> b971 <==
       # S1
       @keys =
          grep {
/^_$keyprefix$type/i;
          } (
              keys (
                     %{$self} )
          );

       # s2
       @keys =
          grep {
/^_$keyprefix$type/i;
          } (
              keys (
                     %{$self} )
          );

==> b972 <==
          # 3 cycle
          $rev_order =
            (
                    $exons[0]->end() <$exons[1]->start()
                    ? 0
                    : 1) ;

          $rev_order =
            (
                    $exons[0]->end() <$exons[1]->start()
                    ? 0
                    : 1) ;

          $rev_order =
            (
                    $exons[0]->end() <$exons[1]->start()
                    ? 0
                    : 1) ;

          $rev_order =
            (
                    $exons[0]->end() <$exons[1]->start()
                    ? 0
                    : 1) ;

          # Stable
          $rev_order =
            (
                    $exons[0]->end() <$exons[1]->start()
                    ? 0
                    : 1) ;

==> b973 <==
    my @translations = (
        $self
          ->transexonscreation(
            $dna, \@transcripts
          )
    );

    my @translations = (
        $self
          ->transexonscreation(
            $dna, \@transcripts
          )
    );

==> b974 <==
    $self->{'H'}=
          [
              $self->catfile(
                  $self->updir,'Encode', 'encode.h'
              )
          ];

    $self->{'H'}=
          [
              $self->catfile(
                  $self->updir,'Encode', 'encode.h'
              )
          ];

==> b975 <==
foreach my $x (
              sort { lc($a) cmp lc($b) }
                keys %INC
  )

__END__

foreach my $x (
         sort {
                  lc($a) cmp lc($b)
         }
         keys %INC
  )

==> b977 <==
     threads->create(
          sub { lock($COUNT) ; $COUNT++ ; }
     )->join() ;

     threads->create(
          sub { lock($COUNT) ; $COUNT++ ; }
     )->join() ;

     threads->create(
          sub { lock($COUNT) ; $COUNT++ ; } )->join() ;

==> b978 <==
     $ans = threads->create( sub {
          threads->create(
               sub { $p->greeting  } )->join ;
     } )->join ;

     $ans = threads->create( sub {
          threads->create(
               sub { $p->greeting  }
          )->join ;
     } )->join ;


==> b979 <==
$self->{'H'}=
      [
          $self->catfile(
              $self->updir,'Encode', 'encode.h'
          )
      ];

$self->{'H'}=
      [
          $self->catfile(
              $self->updir,'Encode', 'encode.h'
          )
      ];

==> b981 <==
    $self->{'H'} =
          [
              $self->catfile(
                  $self->updir, 'Encode', 'encode.h'
              )
          ];

    $self->{'H'} =
          [
              $self->catfile(
                  $self->updir, 'Encode', 'encode.h'
              )
          ];


==> b982 <==
                              do {
                                    ok(   0 ==capture_warnings(
                                                sub {
                                                      $_ = "x" ;
                                                      eval
"$strict no warnings '$warning_type'; $regex;"
                                                             ;
                                                }
                                          ),
"... and turning off '$warning_type' warnings suppressed it"
                                    ) ;
                                     }

                                     # S2
                                     do {
                                    ok(   0 ==capture_warnings(
                                                sub {
                                                      $_ = "x" ;
                                                      eval
"$strict no warnings '$warning_type'; $regex;"
                                                             ;
                                                }
                                          ),
"... and turning off '$warning_type' warnings suppressed it"
                                    ) ;
                              }


==> b983 <==
            # S1
            my $arg = {
                module => sub
                {
                    [ $self->containsmods ]
                },
            };

            # S2
            my $arg = {
                module => sub
                {
                    [ $self->containsmods ]
                },
            };

==> b984 <==
          unless (
                    exists $self->{
                              'accession_number'} )
          {       return "unknown";
          }

          unless (
                    exists $self->{
                              'accession_number'} )
          {       return "unknown";
          }


==> b985 <==
          # State 1
          if (
                    $seqType =~ /list|array/i )
          {       return ( '', '' )
                      unless
                      defined $self->{
                              '_queryStrand'};
          }

          #State 2
          if (
                    $seqType =~ /list|array/i )
          {       return ( '', '' )
                      unless
                      defined $self->{
                              '_queryStrand'};
          }


==> b988 <==
my $seq = (
    new Bio::SeqIO(
        '-format' =>
          'fasta',
        '-file' =>
          Bio::Root::IO
          ->catfile(
            "t",
"AAC12660.fa"
          )
    )
)->next_seq();

==> b989 <==
my $branch = (
       split( m#/#, $branchdata )
)[5];

my $branch = (
       split( m#/#, $branchdata )
)[5];


==> b990 <==
    print
    H;

    print
    H;


==> b991 <==
                    if(
                              &y_or_n
                              (
                                        <<EOT,1))
Bubba
EOT
                          if
                          (
                              &y_or_n
                              (
                                        <<EOT,1))
Bubba
EOT

==> b992 <==
    my @translations = (
        $self->transexonscreation(
            $dna, \@transcripts )
    );

==> b994 <==
# State 1
do
sub :
lvalue
{
    return;
}

# State 2
do
sub :
lvalue
{
    return;
}

==> b995 <==
eval{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{{{{{
         {
                  {}
         }
}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}};

eval{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{
         {
                  {}
         }
}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}};

==> b996 <==
        $x=
          &{ $C
                  . "::__strip_zeros"
          }
          ([0,1,2,0,0,0]) ;

        $x=
          &{ $C
                  . "::__strip_zeros"
          }
          ([0,1,2,0,0,0]) ;

==> b997 <==
        $x=
          &{$CALC
                  ."::__strip_zeros"
          }([0,1,2,0,0,0]);

        $x=
          &{$CALC
                  ."::__strip_zeros"
          }([0,1,2,0,0,0]);

==> b998 <==
eval
{ { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { {
{ { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { {
{ { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { {
{ { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { { {
{ { { { { { {} } } } } } }
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } };

==> b999 <==
            # S1
            while (
                $line =~

s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e
              )
__END__

# S2
            while (
                $line =~

s/^([^\t]*)(\t+)/$1.(" " x ((length($2)<<3)-(length($1)&7)))/e )


==> c100 <==
                # Starting
                eval {
                    substr( $$textref, $_[4], $_[1] + $_[5] ) = $extra;
                } # need to check for sort_map_grep_eval in starting_one_line_block

                  # Stable
                  eval {
                    substr( $$textref, $_[4], $_[1] + $_[5] ) = $extra;
                  } # need to check for sort_map_grep_eval in starting_one_line_block

                  # Starting (note ';' before '#' )
                  eval { substr( $$textref, $_[4], $_[1] + $_[5] ) = $extra; }; # need to check for sort_map_grep_eval in starting_one_line_block

                # Stable (note ';' before '#' )
                eval { substr( $$textref, $_[4], $_[1] + $_[5] ) = $extra; }; # need to check for sort_map_grep_eval in starting_one_line_block

==> c169 <==
    eval "format OUT19 = \n" . '@<<<' . "\0\n" . '$v' . "\n" . '@<<<' . "\0\n"
      . '$v' . "\n.\n";

==> c190 <==
        # reverse sweep needs to look at '$saw_level_change' for these cases
        local ($codeA)
            = "sub wrap_cmd_$cmd {" . "\n"
            . 'local($cmd, $_) = @_; local ($args, $dummy, $pat) = "";'
            . $bodyA
            . ( ($thisone)
                ? "\nprint \"\\nwrap $cmd:\".\$args.\"\\n\";"
                : ''
            )
            . "\n"
            . '(&make_deferred_wrapper(1).$cmd.'
            . "\"$padding\""
            . '.$args.&make_deferred_wrapper(0),$_)}' . "\n";

        local ($codeA)
            = "sub wrap_cmd_$cmd {" . "\n"
            . 'local($cmd, $_) = @_; local ($args, $dummy, $pat) = "";'
            . $bodyA
            . ( ($thisone)
                ? "\nprint \"\\nwrap $cmd:\".\$args.\"\\n\";"
                : ''
            )
            . "\n"
            . '(&make_deferred_wrapper(1).$cmd.'
            . "\"$padding\""
            . '.$args.&make_deferred_wrapper(0),$_)}' . "\n";

==> c302 <==
use strict;
use warnings;

use Params::Validate qw(:all);

use PVTests;
use Test::More 0.88;
my $String = 'foo';    # blank after this opens and closes

my $Foo  = bless \$v1, 'Foo';
my $Bar  = bless \$v2, 'Bar';
my $Baz  = bless \$v3, 'Baz';
my $Quux = bless \$v4, 'Quux';
my $v1;
my ( $v1, $v2, $v3, $v4 );


==> c314 <==
my $map ={
dtend =>
    {                                                                 # 4.8.2.2
    },
} ;

==> c400 <==
Readonly::Array
   my @PATTERNS
   => ( # requires this side comment
[
  'A-Z',
  'a-z',
  '0-9',
  '_'
] => [
      '\\w',
      '\\W'
],
[
  'A-Z',
  'a-z'
] => [
'[[:alpha:]]',
'[[:^alpha:]]'
],
   );
